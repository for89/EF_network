---
title: "Mapping the Structure of Executive Function in Early Childhood: A Network Analysis Approach" 
shorttitle: "Mapping Executive Function"

author:
- name: "Fionnuala O'Reilly" 
  orcid: 0000-0002-4355-9088 
  affiliations: 
    - ref: stanford
  email: foreilly@stanford.edu
  corresponding: true

- name: "Jelena Sucevic" 
  orcid: 0000-0001-5091-5434 
  affiliations: 
    - ref: oxford
    
- name: "Caylee Cook"
  orcid: 0000-0001-9718-8887
  affiliations:
    - ref: witwatersrand
    
- name: "Catherine Draper"
  orcid: 0000-0002-2885-437X
  affiliations:
    - ref: witwatersrand

- name: "Steven Howard" 
  orcid: 0000-0002-1258-3210 
  affiliations: 
    - ref: oxford

- name: "Gaia Scerif" 
  orcid: 0000-0002-6371-8874 
  affiliations: 
    - ref: oxford

affiliations: 
  - id: stanford 
    name: "Stanford University" 
  - id: oxford 
    name: "University of Oxford" 
  - id: witwatersrand 
    name: "University of the Witwatersrand"

author-note: 
  disclosures: 
    financial-support: "This work was supported by X." 
    conflict-of-interest: "The author has no conflict of interest to declare."

abstract: TO BE ADDED.

keywords: ["executive function"] 
word-count: true

project:
  type: default
  
bibliography: library.bib

floatsintext: true
numbered-lines: true
# draft: false
mask: false

# figurelist: no
# tablelist: no
# footnotelist: no

format:
  apaquarto-pdf:
    documentmode: man
    keep-tex: true
    include-in-header: preamble.tex
    fig-format: png
   
knitr:
  opts_chunk:
    ft.arraystretch: 1.25

execute:
  echo: false 
  message: false 
  warning: false 
  error: true 
  cache: true
---

```{r setup}
#| label: packages
#| include: false
#| cache: false

library(tidyverse)
library(here)
library(glue)
library(purrr)
library(viridis)
library(flextable)
library(lavaan)
library(broom.mixed)
library(lmerTest)
library(png)
library(emmeans)
library(dplyr)
library(ggplot2)
library(stringr)
library(psych) 
library(tibble)
library(haven)
library(BGGM)
library(networktools)  
library(qgraph)
library(haven)
library(readxl)
library(tidyr)
library(readr)


if (requireNamespace("conflicted", quietly = TRUE)) {
  conflicted::conflicts_prefer(
    dplyr::select,
    dplyr::filter,
    dplyr::lag,
    dplyr::rename,
    tidyr::extract
  )
  options(conflicted.policy = "strict") 
}
```

```{r}
#| label: plot-helper
#| include: false

source(here::here("ef_network_plotting_helper.R"))
```

```{r}
#| label: load-aus-data
#| include: false
#| cache: false

aus_data <- read_sav("REDACTED")
colnames(aus_data)
# view(aus_data)
```

```{r}
#| label: load-sa-data
#| include: false
#| cache: false

# sa_data <- read_csv("REDACTED")

# Caylee's do file as text file
path <- "REDACTED"
system2("open", path)

do_lines <- read_lines("REDACTED")

idx <- which(str_detect(do_lines, "^\\s*import\\s+delimited\\b"))[1]
stopifnot(!is.na(idx))

line <- do_lines[idx]

# remove "import delimited", then keep the varlist (everything before " using ")
tmp <- line |>
  str_remove("^\\s*import\\s+delimited\\s+") |>
  str_split("\\s+using\\s+", n = 2, simplify = TRUE)

varlist <- tmp[1]  # everything before "using"

cols <- str_split(str_squish(varlist), "\\s+")[[1]]

sa_data <- read_csv(
  "REDACTED",
  col_names = FALSE
)

stopifnot(length(cols) == ncol(sa_data))
names(sa_data) <- cols

# checks
length(cols)
ncol(sa_data)

#datasets
colnames(aus_data)
colnames(sa_data)
```

```{r}


table(sa_data$hle_read_books)
table(sa_data$hle_read_who___1)
table(sa_data$hle_read_who___2)
table(sa_data$hle_read_who___3)
table(sa_data$hle_read_who___4)
table(sa_data$hle_read_who___5)
table(sa_data$hle_read_who___6)
table(sa_data$hle_read_who___unk)
table(sa_data$hle_read_who___na)
table(sa_data$hle_read_who___999)
table(sa_data$hle_read_who___9999)
table(sa_data$hle_read_specify)
table(sa_data$hle_stories)    
table(sa_data$hle_stories_who___1)
table(sa_data$hle_stories_who___2)
table(sa_data$hle_stories_who___3)
table(sa_data$hle_stories_who___4)
table(sa_data$hle_stories_who___5)
table(sa_data$hle_stories_who___6)
table(sa_data$hle_stories_who___unk)
table(sa_data$hle_stories_who___na)
table(sa_data$hle_stories_who___999)
table(sa_data$hle_stories_who___9999)
table(sa_data$hle_stories_specify)
table(sa_data$hle_songs)
table(sa_data$hle_songs_who___1)
table(sa_data$hle_songs_who___2)
table(sa_data$hle_songs_who___3)
table(sa_data$hle_songs_who___4)
table(sa_data$hle_songs_who___5)
table(sa_data$hle_songs_who___6)
table(sa_data$hle_songs_who___unk)
table(sa_data$hle_songs_who___na)
table(sa_data$hle_songs_who___999)
table(sa_data$hle_songs_who___9999)
table(sa_data$hle_songs_specify)
table(sa_data$hle_outside)
table(sa_data$hle_outside_who___1)
table(sa_data$hle_outside_who___2)
table(sa_data$hle_outside_who___3)
table(sa_data$hle_outside_who___4)
table(sa_data$hle_outside_who___5)
table(sa_data$hle_outside_who___6)
table(sa_data$hle_outside_who___unk)
table(sa_data$hle_outside_who___na)
table(sa_data$hle_outside_who___999)
table(sa_data$hle_outside_who___9999)
table(sa_data$hle_outside_specify)
table(sa_data$hle_play)
table(sa_data$hle_play_who___1)
table(sa_data$hle_play_who___2)
table(sa_data$hle_play_who___3)
table(sa_data$hle_play_who___4)
table(sa_data$hle_play_who___5)
table(sa_data$hle_play_who___6)
table(sa_data$hle_play_who___unk)
table(sa_data$hle_play_who___na)
table(sa_data$hle_play_who___999)
table(sa_data$hle_play_who___9999)
table(sa_data$hle_play_specify)
table(sa_data$hle_names)
table(sa_data$hle_names_who___1)
table(sa_data$hle_names_who___2)
table(sa_data$hle_names_who___3)
table(sa_data$hle_names_who___4)
table(sa_data$hle_names_who___5)
table(sa_data$hle_names_who___6)
table(sa_data$hle_names_who___unk)
table(sa_data$hle_names_who___na)
table(sa_data$hle_names_who___999)
table(sa_data$hle_names_who___999)
table(sa_data$hle_names_specify)
table(sa_data$hle_count)
table(sa_data$hle_count_who___1)
table(sa_data$hle_count_who___2)
table(sa_data$hle_count_who___3)
table(sa_data$hle_count_who___4)
table(sa_data$hle_count_who___5)
table(sa_data$hle_count_who___6)
table(sa_data$hle_count_who___unk)
table(sa_data$hle_count_who___na)
table(sa_data$hle_count_who___999)
table(sa_data$hle_count_who___9999)
table(sa_data$hle_count_specify)
table(sa_data$hle_draw)
table(sa_data$hle_draw_who___1)
table(sa_data$hle_draw_who___2)
table(sa_data$hle_draw_who___3)
table(sa_data$hle_draw_who___4)
table(sa_data$hle_draw_who___5)
table(sa_data$hle_draw_who___6)
table(sa_data$hle_draw_who___unk)
table(sa_data$hle_draw_who___na)
table(sa_data$hle_draw_who___999)
table(sa_data$hle_draw_who___9999)
table(sa_data$hle_draw_specify)
table(sa_data$hle_freqency_score)
table(sa_data$hle_time_week)
table(sa_data$hle_time_weekend)
table(sa_data$total_time_with_child)
table(sa_data$hle_books_home)
table(sa_data$hle_books_number)
table(sa_data$hle_homemade_toys)
table(sa_data$hle_homemade_toys_specify)
table(sa_data$hle_toys_shop)
table(sa_data$hle_toys_shop_specify)
table(sa_data$hle_household_objects)
table(sa_data$hle_objects_specify)
table(sa_data$books_toys_house_total)

```


```{r}
#| label: derive-hle-vars
#| echo: true
#| label: derive-hle-vars
#| echo: true


to_num <- function(x) suppressWarnings(as.numeric(as.character(x)))

# (1) HLA frequency (8 items: 0/1/2) -> range 0..16
hla_freq_vars <- c(
  "hle_read_books", "hle_stories", "hle_songs", "hle_outside",
  "hle_play", "hle_names", "hle_count", "hle_draw"
)

# (2) Unique caregiver types across any activity (codes 1..6)
activities <- c("read", "stories", "songs", "outside", "play", "names", "count", "draw")
caregiver_codes <- 1:6

# (3) Books/toys total (4 items: 0/1) -> range 0..4
books_toys_vars <- c(
  "hle_books_home", "hle_homemade_toys", "hle_toys_shop", "hle_household_objects"
)

# (4) Time total: week + weekend (each 1..3) -> range 2..6
time_vars <- c("hle_time_week", "hle_time_weekend")

# ---- derive (1), (3), (4) ----
sa_data <- sa_data %>%
  mutate(
    hla_frequency1 = if_else(
      if_any(all_of(hla_freq_vars), is.na),
      NA_real_,
      rowSums(across(all_of(hla_freq_vars), to_num))
    ),
    books_toys_total1 = if_else(
      if_any(all_of(books_toys_vars), is.na),
      NA_real_,
      rowSums(across(all_of(books_toys_vars), to_num))
    ),
    time_total1 = if_else(
      if_any(all_of(time_vars), is.na),
      NA_real_,
      rowSums(across(all_of(time_vars), to_num))
    )
  )

# ---- derive (2): num_caregivers ----
who_all <- as.vector(sapply(
  activities,
  function(a) paste0("hle_", a, "_who___", caregiver_codes)
))

who_mat <- as.matrix(sa_data[, who_all, drop = FALSE])
all_missing_who <- rowSums(!is.na(who_mat)) == 0

present_mat <- sapply(caregiver_codes, function(k) {
  X <- as.matrix(sa_data[, paste0("hle_", activities, "_who___", k), drop = FALSE])
  X[is.na(X)] <- 0
  rowSums(X) > 0
})

sa_data$num_caregivers <- rowSums(present_mat)
sa_data$num_caregivers[all_missing_who] <- NA_integer_

# checks
summary(sa_data$hla_frequency1)
summary(sa_data$num_caregivers)
summary(sa_data$books_toys_total1)
summary(sa_data$time_total1)

# quick distributions
table(sa_data$hla_frequency1, useNA = "ifany")
table(sa_data$num_caregivers, useNA = "ifany")
table(sa_data$books_toys_total1, useNA = "ifany")
table(sa_data$time_total1, useNA = "ifany")

# key consistency check: activities reported but "0 caregivers"
with(sa_data, table(hla_frequency1 > 0, num_caregivers == 0, useNA = "ifany"))

sa_data <- sa_data %>%
  mutate(
    num_caregivers_clean = ifelse(hla_frequency1 > 0 & num_caregivers == 0, NA_integer_, num_caregivers)
  )

sum(sa_data$hla_frequency1 > 0 & sa_data$num_caregivers == 0, na.rm = TRUE)
sum(sa_data$hla_frequency1 > 0 & is.na(sa_data$num_caregivers_clean), na.rm = TRUE) # n=84 with no caregiver info. reported.

```

```{r}
#| label: setup-helpers
#| include: false

library(gt)
# Formatting helpers
fmt_mean_sd <- function(mean, sd, digits = 2) {
  ifelse(
    is.na(mean) | is.na(sd),
    NA_character_,
    sprintf(paste0("%.", digits, "f (%.", digits, "f)"), mean, sd)
  )
}

fmt_med_rng <- function(median, min, max, digits = 2) {
  ifelse(
    is.na(median) | is.na(min) | is.na(max),
    NA_character_,
    sprintf(paste0("%.", digits, "f [%.", digits, "f, %.", digits, "f]"),
            median, min, max)
  )
}

# Table helper 
# EF descriptives (expects standard long format)
# ef_long: country, timepoint, id, variable, value
# any_ids: country, timepoint, id
summ_ef_desc <- function(ef_long, any_ids) {
  stopifnot(all(c("country","timepoint","id","variable","value") %in% names(ef_long)))
  stopifnot(all(c("country","timepoint","id") %in% names(any_ids)))

  ef_long %>%
    inner_join(distinct(any_ids, country, timepoint, id),
               by = c("country","timepoint","id")) %>%
    group_by(country, timepoint, variable) %>%
    summarise(
      n      = sum(!is.na(value)),
      mean   = ifelse(all(is.na(value)), NA_real_, mean(value, na.rm = TRUE)),
      sd     = ifelse(sum(!is.na(value)) > 1, sd(value, na.rm = TRUE), NA_real_),
      median = ifelse(all(is.na(value)), NA_real_, median(value, na.rm = TRUE)),
      min    = ifelse(all(is.na(value)), NA_real_, min(value, na.rm = TRUE)),
      max    = ifelse(all(is.na(value)), NA_real_, max(value, na.rm = TRUE)),
      .groups = "drop"
    )
}

# Sample sizes + EF completeness within anchored sample
summ_sizes <- function(ef_long, any_ids, n_measures_complete = 3) {
  stopifnot(all(c("country","timepoint","id") %in% names(any_ids)))
  stopifnot(all(c("country","timepoint","id","variable","value") %in% names(ef_long)))

  ef_long_anch <- ef_long %>%
    inner_join(distinct(any_ids, country, timepoint, id),
               by = c("country","timepoint","id"))

  complete_by_child <- ef_long_anch %>%
    distinct(country, timepoint, id, variable, .keep_all = TRUE) %>%
    group_by(country, timepoint, id) %>%
    summarise(n_nonmiss_measures = sum(!is.na(value)), .groups = "drop")

  complete_by_child %>%
    group_by(country, timepoint) %>%
    summarise(
      n_children_any_ef = n_distinct(id),
      n_complete_ef     = sum(n_nonmiss_measures >= n_measures_complete),
      pct_complete_ef   = round(100 * mean(n_nonmiss_measures >= n_measures_complete), 1),
      .groups = "drop"
    )
}

# Age descriptives within EF-anchored sample
summ_age_long <- function(age_long, any_ids) {
  stopifnot(all(c("country","timepoint","id") %in% names(any_ids)))
  stopifnot(all(c("country","timepoint","id","age") %in% names(age_long)))

  age_long %>%
    inner_join(distinct(any_ids, country, timepoint, id),
               by = c("country","timepoint","id")) %>%
    mutate(age = as.numeric(age)) %>%
    group_by(country, timepoint) %>%
    summarise(
      age_n      = sum(!is.na(age)),
      age_mean   = ifelse(age_n > 0, mean(age, na.rm = TRUE), NA_real_),
      age_sd     = ifelse(age_n > 1, sd(age, na.rm = TRUE), NA_real_),
      age_median = ifelse(age_n > 0, median(age, na.rm = TRUE), NA_real_),
      age_min    = ifelse(age_n > 0, min(age, na.rm = TRUE), NA_real_),
      age_max    = ifelse(age_n > 0, max(age, na.rm = TRUE), NA_real_),
      .groups = "drop"
    )
}

# Categorical descriptives by timepoint (anchored)
# df must have: country,timepoint,id,var
desc_cat_tp <- function(df, var, any_ids, variable_label) {
  stopifnot(all(c("country","timepoint","id") %in% names(df)))
  stopifnot(all(c("country","timepoint","id") %in% names(any_ids)))
  stopifnot(var %in% names(df))

  df %>%
    inner_join(distinct(any_ids, country, timepoint, id),
               by = c("country","timepoint","id")) %>%
    distinct(country, timepoint, id, .data[[var]]) %>%
    count(country, timepoint, .data[[var]], name = "n") %>%
    group_by(country, timepoint) %>%
    mutate(pct = 100 * n / sum(n)) %>%
    ungroup() %>%
    transmute(
      country,
      timepoint,
      variable = variable_label,
      level    = as.character(.data[[var]]),
      cell     = paste0(n, " (", sprintf("%.1f", pct), "%)")
    )
}
```

```{r}
#| label: build-sa-aus-objects
#| include: false

stopifnot(exists("sa_data"))
stopifnot(exists("aus_data"))

# SA: subset -> long -> anchor -> standard long objects
eyt_vars <- c(
  "date_of_eyt", "eyt_child_age_at_testing", "eyt2_ageinmonths", "time_btwn_testing",
  "ef_inhibition", "ef_cogflex", "ef_workingmem",
  "refuse_missing_eyt", "notes_eyt", "early_years_toolbox_complete"
)

ses_vars <- c(
  "nids_income_1", "nids_income_2", "nids_income_3",
  "nids_income_4", "nids_income_5", "nids_income_6",
  "income_range", "monthly_income_given",
  "marital_status", "education_school", "education_post_school", "education_post_school_b",
  "children_in_house", "adults_in_house", "total_in_household"
)

id_vars <- c(
  "caregiver_child_studyid", "redcap_event_name", "interview_date",
  "ra", "child_id", "caregiver_id",
  "child_sex", "child_dob", "child_age", "child_birthweight",
  "caregiver_dob", "caregiver_age", "relationship_child",
  "child_education", "child_education_specific", "child_education_frequency"
)

sa_subset_long <- sa_data %>%
  select(any_of(c(id_vars, ses_vars, eyt_vars))) %>%
  distinct(caregiver_child_studyid, redcap_event_name, .keep_all = TRUE)

ef_sa <- c("ef_inhibition", "ef_cogflex", "ef_workingmem")

# native anchor (event + child)
sa_any_ef_ids_by_tp <- sa_subset_long %>%
  filter(if_any(all_of(ef_sa), ~ !is.na(.x))) %>%
  distinct(redcap_event_name, caregiver_child_studyid)

# event -> timepoint map (single source of truth)
if ("interview_date" %in% names(sa_subset_long)) {
  sa_tp_map_tmp <- sa_subset_long %>%
    distinct(redcap_event_name, interview_date) %>%
    mutate(interview_date = suppressWarnings(as.Date(interview_date))) %>%
    group_by(redcap_event_name) %>%
    summarise(first_date = suppressWarnings(min(interview_date, na.rm = TRUE)), .groups = "drop") %>%
    mutate(first_date = ifelse(is.infinite(first_date), as.Date(NA), as.Date(first_date)))

  use_dates <- any(!is.na(sa_tp_map_tmp$first_date))

  sa_tp_map <- if (use_dates) {
    sa_tp_map_tmp %>%
      inner_join(distinct(sa_any_ef_ids_by_tp, redcap_event_name), by = "redcap_event_name") %>%
      arrange(first_date, redcap_event_name) %>%
      mutate(timepoint = paste0("T", row_number())) %>%
      select(redcap_event_name, timepoint)
  } else {
    sa_any_ef_ids_by_tp %>%
      distinct(redcap_event_name) %>%
      arrange(redcap_event_name) %>%
      mutate(timepoint = paste0("T", row_number()))
  }
} else {
  sa_tp_map <- sa_any_ef_ids_by_tp %>%
    distinct(redcap_event_name) %>%
    arrange(redcap_event_name) %>%
    mutate(timepoint = paste0("T", row_number()))
}

# standardised anchor ids: country,timepoint,id
sa_any_ids <- sa_any_ef_ids_by_tp %>%
  left_join(sa_tp_map, by = "redcap_event_name") %>%
  transmute(country = "SA", timepoint, id = caregiver_child_studyid)

# SA EF long (standard)
sa_ef_long <- sa_subset_long %>%
  inner_join(sa_any_ef_ids_by_tp, by = c("redcap_event_name","caregiver_child_studyid")) %>%
  left_join(sa_tp_map, by = "redcap_event_name") %>%
  transmute(
    country   = "SA",
    timepoint = timepoint,
    id        = caregiver_child_studyid,
    across(all_of(ef_sa), as.numeric)
  ) %>%
  pivot_longer(cols = all_of(ef_sa), names_to = "variable", values_to = "value") %>%
  select(country, timepoint, id, variable, value)

# SA age long (standard; anchoring happens later)
sa_age_long <- sa_subset_long %>%
  left_join(sa_tp_map, by = "redcap_event_name") %>%
  transmute(
    country   = "SA",
    timepoint = timepoint,
    id        = caregiver_child_studyid,
    age       = as.numeric(child_age)
  )

# SA SES (standard; NO harmonising; anchoring happens later)
sa_ses <- sa_subset_long %>%
  left_join(sa_tp_map, by = "redcap_event_name") %>%
  transmute(
    country   = "SA",
    timepoint = timepoint,
    id        = caregiver_child_studyid,
    edu_sa    = if_else(education_post_school == 1,
                        as.integer(education_post_school_b),
                        NA_integer_),
    income_sa = as.character(income_range)
  )

# AUS: wide -> standard EF long + anchors + age + SES
id_var <- if ("CID" %in% names(aus_data)) "CID" else "ServiceID"

t1_vars <- c("MrAnt_Pt_T1","GNG_IC_T1","CS_SwAcc_T1")
t2_vars <- c("MrAnt_Pt_T2","GNG_IC_T2","CS_SwAcc_T2")
t3_vars <- c("MrAnt_Pt_T3","GNG_IC_T3","CS_SwAcc_T3")
ef_vars <- c(t1_vars, t2_vars, t3_vars)

stopifnot(all(ef_vars %in% names(aus_data)))

aus_ef_long <- aus_data %>%
  mutate(id = .data[[id_var]]) %>%
  filter(!is.na(id)) %>%
  select(id, all_of(ef_vars)) %>%
  pivot_longer(
    cols = -id,
    names_to = c("measure", "wave"),
    names_pattern = "^(.*)_T([123])$",
    values_to = "value"
  ) %>%
  mutate(
    country   = "Australia",
    timepoint = paste0("T", wave),
    variable  = recode(measure,
      "MrAnt_Pt" = "ef_workingmem",
      "GNG_IC"   = "ef_inhibition",
      "CS_SwAcc" = "ef_cogflex"
    ),
    value = as.numeric(value)
  ) %>%
  select(country, timepoint, id, variable, value)

aus_any_ids <- aus_ef_long %>%
  group_by(country, timepoint, id) %>%
  summarise(any_ef = any(!is.na(value)), .groups = "drop") %>%
  filter(any_ef) %>%
  select(country, timepoint, id)

stopifnot(all(c("Age_T1","Age_T2","Age_T3") %in% names(aus_data)))

aus_age_long <- aus_data %>%
  mutate(id = .data[[id_var]]) %>%
  filter(!is.na(id)) %>%
  select(id, Age_T1, Age_T2, Age_T3) %>%
  pivot_longer(cols = starts_with("Age_T"), names_to = "timepoint", values_to = "age") %>%
  mutate(
    country   = "Australia",
    timepoint = gsub("^Age_", "", timepoint),
    age       = as.numeric(age)
  ) %>%
  select(country, timepoint, id, age)

stopifnot(all(c("A2_MatEdu","A3_FamIncome") %in% names(aus_data)))

# child-level SES (native coding)
aus_ses_child <- aus_data %>%
  mutate(id = .data[[id_var]]) %>%
  filter(!is.na(id)) %>%
  distinct(id, .keep_all = TRUE) %>%
  transmute(
    country    = "Australia",
    id,
    edu_aus    = as.integer(A2_MatEdu),     # 1–5
    income_aus = as.character(A3_FamIncome) # 1–3
  )

# expand across anchored timepoints
aus_ses_tp <- aus_any_ids %>%
  left_join(aus_ses_child, by = c("country","id"))
```

```{r}
#| label: summarise-table1-components
#| include: false

ef_labels <- c(
  ef_inhibition = "Inhibition",
  ef_cogflex    = "Cognitive flexibility",
  ef_workingmem = "Working memory"
)

tp_sizes <- bind_rows(
  summ_sizes(sa_ef_long,  sa_any_ids,  n_measures_complete = 3),
  summ_sizes(aus_ef_long, aus_any_ids, n_measures_complete = 3)
) %>% arrange(country, timepoint)

tp_age <- bind_rows(
  summ_age_long(sa_age_long,  sa_any_ids),
  summ_age_long(aus_age_long, aus_any_ids)
) %>% arrange(country, timepoint)

tp_ef_desc <- bind_rows(
  summ_ef_desc(sa_ef_long,  sa_any_ids),
  summ_ef_desc(aus_ef_long, aus_any_ids)
) %>% arrange(country, timepoint, variable)

# SES distributions (anchored)
sa_edu_tp    <- desc_cat_tp(sa_ses,    "edu_sa",    sa_any_ids,  "Caregiver education (SA)")
sa_income_tp <- desc_cat_tp(sa_ses,    "income_sa", sa_any_ids,  "Household income (SA)")
aus_edu_tp   <- desc_cat_tp(aus_ses_tp,"edu_aus",   aus_any_ids, "Caregiver education (AUS)")
aus_income_tp<- desc_cat_tp(aus_ses_tp,"income_aus",aus_any_ids, "Household income (AUS)")

ses_tp_long <- bind_rows(sa_edu_tp, sa_income_tp, aus_edu_tp, aus_income_tp) %>%
  arrange(country, timepoint, variable, level)
```

::: {.landscape}
```{r}
#| label: render-table1
#| include: true
#| ft.arraystretch: 1

group_levels <- tp_sizes %>%
  mutate(group = paste(country, timepoint, sep = " — ")) %>%
  arrange(match(country, c("SA","Australia")), timepoint) %>%
  pull(group) %>%
  unique()

metrics_long <- bind_rows(
  tp_sizes %>%
    mutate(group = paste(country, timepoint, sep = " — ")) %>%
    transmute(section = "Sample size (anchored on any EF)", row = "EF anchor N", group,
              value = as.character(n_children_any_ef)),

  tp_sizes %>%
    mutate(group = paste(country, timepoint, sep = " — ")) %>%
    transmute(section = "Sample size (anchored on any EF)", row = "EF complete N (%)", group,
              value = paste0(n_complete_ef, " (", pct_complete_ef, "%)")),

  tp_age %>%
    mutate(group = paste(country, timepoint, sep = " — ")) %>%
    transmute(section = "Age", row = "Age (years), Mean (SD)", group,
              value = fmt_mean_sd(age_mean, age_sd, digits = 2)),

  tp_age %>%
    mutate(group = paste(country, timepoint, sep = " — ")) %>%
    transmute(section = "Age", row = "Age (years), Median [min, max]", group,
              value = fmt_med_rng(age_median, age_min, age_max, digits = 2)),

  tp_ef_desc %>%
    mutate(group = paste(country, timepoint, sep = " — "),
           domain = unname(ef_labels[as.character(variable)])) %>%
    transmute(section = "Executive function", row = paste0(domain, ", n"), group,
              value = as.character(n)),

  tp_ef_desc %>%
    mutate(group = paste(country, timepoint, sep = " — "),
           domain = unname(ef_labels[as.character(variable)])) %>%
    transmute(section = "Executive function", row = paste0(domain, ", Mean (SD)"), group,
              value = fmt_mean_sd(mean, sd, digits = 2))
)

metrics_wide <- metrics_long %>%
  mutate(group = factor(group, levels = group_levels)) %>%
  select(section, row, group, value) %>%
  pivot_wider(names_from = group, values_from = value) %>%
  arrange(section, row)

ses_wide <- ses_tp_long %>%
  mutate(group = paste(country, timepoint, sep = " — "),
         group = factor(group, levels = group_levels)) %>%
  transmute(section = variable, row = level, group, value = cell) %>%
  pivot_wider(names_from = group, values_from = value) %>%
  arrange(section, row)

paper_table <- bind_rows(metrics_wide, ses_wide) %>%
  mutate(section = factor(section, levels = c(
    "Sample size (anchored on any EF)",
    "Age",
    "Executive function",
    "Caregiver education (SA)",
    "Caregiver education (AUS)",
    "Household income (SA)",
    "Household income (AUS)"
  ))) %>%
  arrange(section, row)

paper_gt <- paper_table %>%
  gt(groupname_col = "section", rowname_col = "row") %>%
  tab_header(
    title = "Table 1. Sample characteristics by country and timepoint",
    subtitle = "All summaries are anchored to children with any EF observed at that timepoint (partial EF allowed)."
  ) %>%
  cols_align(align = "center") %>%
  tab_options(
    table.width = pct(100),
    row_group.as_column = TRUE,
    table.font.size = px(11)
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_row_groups()
  )
paper_gt
```
:::

```{r}
#| label: graph-prep
#| include: false

# EF longitudinal exploration

stopifnot(exists("sa_ef_long"), exists("aus_ef_long"))
stopifnot(exists("sa_age_long"), exists("aus_age_long"))

time_levels <- c("T1","T2","T3")
ef_levels   <- c("ef_inhibition","ef_cogflex","ef_workingmem")

ef_labels <- c(
  ef_inhibition = "Inhibition",
  ef_cogflex    = "Cognitive flexibility",
  ef_workingmem = "Working memory"
)

# Combine EF + age

ef_all <- bind_rows(
  sa_ef_long  %>% mutate(id = as.character(id)),
  aus_ef_long %>% mutate(id = as.character(id))
) %>%
  mutate(
    timepoint = factor(timepoint, levels = time_levels, ordered = TRUE),
    variable  = factor(variable,  levels = ef_levels)
  )

age_all <- bind_rows(
  sa_age_long  %>% mutate(id = as.character(id)),
  aus_age_long %>% mutate(id = as.character(id))
) %>%
  mutate(timepoint = factor(timepoint, levels = time_levels, ordered = TRUE))
```

```{r}
#| label: standardize
#| include: false

# pretty labels (define once)
ef_labels_pretty <- c(
  ef_inhibition = "Inhibition",
  ef_cogflex    = "Cognitive flexibility",
  ef_workingmem = "Working memory"
)

ef_std <- ef_all %>%
  dplyr::group_by(variable) %>%
  dplyr::mutate(value_z = as.numeric(scale(value))) %>%
  dplyr::ungroup() %>%
  dplyr::left_join(
    age_all %>% dplyr::select(country, timepoint, id, age),
    by = c("country", "timepoint", "id")
  ) %>%
  dplyr::mutate(
    country = dplyr::recode(country, SA = "South Africa"),
    country = factor(country, levels = c("Australia", "South Africa")),

    # derive task from VARIABLE (not from the existing label)
    task = factor(
      as.character(variable),
      levels = ef_levels,
      labels = unname(ef_labels_pretty[ef_levels])
    )
  )

```

```{r}
#| label: test-re-test
#| include: false

# keep only children who have >1 wave for a given task (within country)
ef_retest_scores <- ef_std %>%
  group_by(country, id, task) %>%
  arrange(country, id, task, timepoint) %>%
  filter(n_distinct(timepoint) > 1) %>%
  ungroup()

# wide format: one row per child × task (within country), columns per wave
# (also widens age so we can compute age gaps)
retest_wide <- ef_retest_scores %>%
  # if you *ever* have duplicates within a wave, this collapses safely
  group_by(country, id, task, timepoint) %>%
  summarise(
    value_z = mean(value_z, na.rm = TRUE),
    age     = mean(age,     na.rm = TRUE),
    .groups = "drop"
  ) %>%
  tidyr::pivot_wider(
    id_cols     = c(country, id, task),
    names_from  = timepoint,
    values_from = c(value_z, age),
    names_sep   = "_"
  ) %>%
  mutate(
    mean_age      = rowMeans(dplyr::select(., dplyr::starts_with("age_")), na.rm = TRUE),
    age_gap_T12_y = age_T2 - age_T1,
    age_gap_T23_y = age_T3 - age_T2
  ) %>%
  select(
    country, id, task,
    mean_age,
    age_gap_T12_y, age_gap_T23_y,
    value_z_T1, value_z_T2, value_z_T3
  )

# helper: only compute r if there are enough complete pairs
safe_cor <- function(a, b, min_n = 3) {
  n <- sum(stats::complete.cases(a, b))
  if (n < min_n) return(NA_real_)
  suppressWarnings(stats::cor(a, b, use = "complete.obs"))
}

# 3) test–retest correlations by country × task
trt <- retest_wide %>%
  group_by(country, task) %>%
  summarise(
    r_T12   = safe_cor(value_z_T1, value_z_T2),
    n_T12   = sum(complete.cases(value_z_T1, value_z_T2)),
    gap_T12 = mean(age_gap_T12_y, na.rm = TRUE) * 12,  # months

    r_T23   = safe_cor(value_z_T2, value_z_T3),
    n_T23   = sum(complete.cases(value_z_T2, value_z_T3)),
    gap_T23 = mean(age_gap_T23_y, na.rm = TRUE) * 12,  # months
    .groups = "drop"
  ) %>%
  arrange(task, country)

trt
```

```{r}
#| label: test-re-test-plot
#| fig-cap: "Executive Function associations across waves. Note: Standardised scores (z); colour indicates mean age across available waves"
#| include: true
#| fig-align: center
#| fig-width: 8
#| fig-height: 8

# From retest_wide -> one row per child × task × pair (T1–T2 and T2–T3), then build a single row facet that only includes observed combos.

retest_long_pairs <- dplyr::bind_rows(
  retest_wide %>%
    dplyr::transmute(
      country, id, task, mean_age,
      pair = "T1–T2",
      x = value_z_T1, y = value_z_T2
    ),
  retest_wide %>%
    dplyr::transmute(
      country, id, task, mean_age,
      pair = "T2–T3",
      x = value_z_T2, y = value_z_T3
    )
) %>%
  dplyr::filter(!is.na(x) & !is.na(y)) %>%
  dplyr::mutate(
    pair = factor(pair, levels = c("T1–T2", "T2–T3")),
    row_facet = paste(country, pair, sep = "\n")
  ) %>%
  dplyr::mutate(
    row_facet = factor(
      row_facet,
      levels = c(
        "Australia\nT1–T2",
        "Australia\nT2–T3",
        "South Africa\nT1–T2"
      )
    )
  )

# Panel stats (r + N), using the same "safe" logic as above
pair_stats <- retest_long_pairs %>%
  dplyr::group_by(country, task, pair, row_facet) %>%
  dplyr::summarise(
    n = sum(stats::complete.cases(x, y)),
    r = safe_cor(x, y, min_n = 3),
    .groups = "drop"
  ) %>%
  dplyr::mutate(
    label = ifelse(
      is.na(r),
      paste0("r = NA\nN = ", n),
      paste0("r = ", sprintf("%.2f", r), "\nN = ", n)
    )
  )

# Plot
p_retest_simple <- ggplot(retest_long_pairs, aes(x = x, y = y)) +
  geom_abline(slope = 1, intercept = 0, linetype = "dotted", alpha = 0.6) +
  geom_point(aes(colour = mean_age), alpha = 0.5, size = 1.4) +
  geom_smooth(method = "lm", formula = y ~ x, se = TRUE) +
  geom_text(
    data = pair_stats,
    aes(label = label),
    x = -Inf, y = Inf,
    inherit.aes = FALSE,
    hjust = -0.05, vjust = 1.1, size = 3.5
  ) +
  facet_grid(row_facet ~ task) +
  labs(
    x = "Earlier wave (z)",
    y = "Later wave (z)",
    colour = "Mean age (years)"
  ) +
  theme(legend.position = "bottom")

p_retest_simple
```

```{r}
#| label: age-ef-wave
#| fig-cap: "Executive Function by age across waves (z-scored within EF task). Note: Points jittered + transparent; lines are linear fits with 95% CI"
#| include: true
#| fig-align: center
#| fig-width: 6
#| fig-height: 6

# Age x EF x wave (standardized)
p_age_by_wave <- ggplot(
  ef_std %>% dplyr::filter(!is.na(age), !is.na(value_z)),
  aes(x = age, y = value_z, colour = country)
) +
  geom_point(
    alpha = 0.15, size = 1,
    position = position_jitter(width = 0.03, height = 0.03)
  ) +
  geom_smooth(
    method = "lm", formula = y ~ x, se = TRUE, linewidth = 1
  ) +
  facet_grid(timepoint ~ task, scales = "fixed") +
  labs(
    #title = "EF by age across waves (z-scored within EF task)",
    #subtitle = "Points jittered + transparent; lines are linear fits with 95% CI",
    x = "Age (years)",
    y = "EF (z-score within task)",
    colour = "Country"
  ) +
  .scale_colour_country() +
  theme(legend.position = "bottom")

p_age_by_wave

```

```{r}
#| label: restricted-sample
#| include: false

# restricted to at least 2 waves sample
# SA: EF at T1 and T2
# Aus: strict (T1+T2+T3) or lenient (T1+T2)

# Wave-level EF presence flag: "any EF observed at this wave"
flags <- ef_std %>%
  dplyr::mutate(
    country = dplyr::recode(as.character(country), SA = "South Africa"),
    id      = as.character(id)
  ) %>%
  dplyr::group_by(country, id, timepoint) %>%
  dplyr::summarise(any_ef = any(!is.na(value_z)), .groups = "drop")

# SA keep: must have T1 & T2
sa_keep_ids <- flags %>%
  dplyr::filter(country == "South Africa", timepoint %in% c("T1","T2")) %>%
  dplyr::group_by(country, id) %>%
  dplyr::summarise(
    has_T1 = any(timepoint == "T1" & any_ef),
    has_T2 = any(timepoint == "T2" & any_ef),
    .groups = "drop"
  ) %>%
  dplyr::filter(has_T1 & has_T2) %>%
  dplyr::select(country, id)

# AUS keep: strict vs lenient
aus_keep_ids_strict <- flags %>%
  dplyr::filter(country == "Australia", timepoint %in% c("T1","T2","T3")) %>%
  dplyr::group_by(country, id) %>%
  dplyr::summarise(
    has_T1 = any(timepoint == "T1" & any_ef),
    has_T2 = any(timepoint == "T2" & any_ef),
    has_T3 = any(timepoint == "T3" & any_ef),
    .groups = "drop"
  ) %>%
  dplyr::filter(has_T1 & has_T2 & has_T3) %>%
  dplyr::select(country, id)

aus_keep_ids_t12 <- flags %>%
  dplyr::filter(country == "Australia", timepoint %in% c("T1","T2")) %>%
  dplyr::group_by(country, id) %>%
  dplyr::summarise(
    has_T1 = any(timepoint == "T1" & any_ef),
    has_T2 = any(timepoint == "T2" & any_ef),
    .groups = "drop"
  ) %>%
  dplyr::filter(has_T1 & has_T2) %>%
  dplyr::select(country, id)

aus_restriction <- "strict"  # "strict" or "t12"
aus_keep_ids <- if (aus_restriction == "strict") aus_keep_ids_strict else aus_keep_ids_t12

keep_ids_all <- dplyr::bind_rows(sa_keep_ids, aus_keep_ids)

ef_restricted <- ef_std %>%
  dplyr::mutate(
    country = dplyr::recode(as.character(country), SA = "South Africa"),
    id      = as.character(id)
  ) %>%
  dplyr::inner_join(keep_ids_all, by = c("country","id"))

```

```{r}
#| label: mean-trend
#| include: true
#| fig-align: center
#| fig-width: 8
#| fig-height: 8
#| fig-cap: |
#|   **Mean EF scores over time (children with repeated EF data).**  
#|   *Note.* “EF observed” at a wave means at least one EF task score is non-missing. The analytic sample includes only children meeting the wave-coverage rule: South Africa = EF observed at both T1 and T2; Australia = EF observed at T1–T3 (“strict”) or at T1 and T2 (“t12”)."

# Mean trend over time (standardised, restricted sample)
mean_df <- ef_restricted %>%
  dplyr::mutate(
    task = factor(as.character(variable),
                  levels = ef_levels,
                  labels = ef_labels_pretty[ef_levels]),
    country = factor(country, levels = c("Australia", "South Africa")),
    timepoint = factor(timepoint, levels = c("T1","T2","T3"))
  ) %>%
  dplyr::group_by(country, task, timepoint) %>%
  dplyr::summarise(
    n  = sum(!is.na(value_z)),
    m  = mean(value_z, na.rm = TRUE),
    se = sd(value_z, na.rm = TRUE) / sqrt(n),
    lo = m - 1.96 * se,
    hi = m + 1.96 * se,
    .groups = "drop"
  )

p_mean_trend <- ggplot(mean_df, aes(x = timepoint, y = m, group = 1)) +
  geom_line(linewidth = 1) +
  geom_point(size = 2.2) +
  geom_errorbar(aes(ymin = lo, ymax = hi), width = 0.10) +
  facet_grid(country ~ task) +
  labs(
    x = "Timepoint",
    y = "Mean EF (z-score)"
  )

p_mean_trend

```

```{r}
#| label: spaghetti-plot
#| include: true
#| fig-align: center
#| fig-width: 8
#| fig-height: 8
#| fig-cap: |
#|   **Individual EF trajectories over time (children with repeated EF data).**  
#|   *Note.* “EF observed” at a wave means at least one EF task score is non-missing. The analytic sample includes only children meeting the wave-coverage rule: South Africa = EF observed at both T1 and T2; Australia = EF observed at T1–T3 (“strict”) or at T1 and T2 (“t12”). Mean ± 95% CI is overlaid. EF scores are z-scored within task (pooled).

# Standardize labels in ef_restricted
ef_restricted_lab <- ef_restricted %>%
  dplyr::mutate(
    country  = dplyr::recode(as.character(country), SA = "South Africa"),
    country  = factor(country, levels = c("Australia", "South Africa")),
    # safest: derive EF domain from the variable code
    task     = factor(as.character(variable),
                      levels = ef_levels,
                      labels = ef_labels_pretty[ef_levels]),
    timepoint = factor(timepoint, levels = c("T1", "T2", "T3")),
    id       = as.character(id)
  )

# Make sure mean_df has the same factor structure
mean_df_lab <- mean_df %>%
  dplyr::mutate(
    country  = dplyr::recode(as.character(country), SA = "South Africa"),
    country  = factor(country, levels = c("Australia", "South Africa")),
    task     = factor(as.character(task),
                      levels = ef_labels_pretty[ef_levels]),  # because mean_df already has pretty labels
    timepoint = factor(timepoint, levels = c("T1", "T2", "T3"))
  )

# plot (no downsampling)
p_spaghetti <- ggplot(ef_restricted_lab, aes(x = timepoint, y = value_z, group = id)) +
  geom_line(alpha = 0.08) +
  geom_point(alpha = 0.08, size = 0.7) +
  geom_line(
    data = mean_df_lab,
    aes(x = timepoint, y = m, group = 1),
    inherit.aes = FALSE,
    linewidth = 1.0
  ) +
  geom_point(
    data = mean_df_lab,
    aes(x = timepoint, y = m),
    inherit.aes = FALSE,
    size = 2.2
  ) +
  geom_errorbar(
    data = mean_df_lab,
    aes(x = timepoint, ymin = lo, ymax = hi),
    inherit.aes = FALSE,
    width = 0.10
  ) +
  facet_grid(country ~ task) +
  labs(
    x = "Timepoint",
    y = "EF (z-score)"
  ) +
  theme(legend.position = "none")
p_spaghetti
```



























