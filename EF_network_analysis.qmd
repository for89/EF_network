---
title: "Mapping the Structure of Executive Function in Early Childhood: A Network Analysis Approach" 
shorttitle: "Mapping Executive Function"

author:
- name: "Fionnuala O'Reilly" 
  orcid: 0000-0002-4355-9088 
  affiliations: 
    - ref: stanford
    - ref: oxford
  email: fionnuala.oreilly@psy.ox.ac.uk
  corresponding: true

- name: "Jelena Sucevic" 
  orcid: 0000-0001-5091-5434 
  affiliations: 
    - ref: oxford
    
- name: "Caylee Cook"
  orcid: 0000-0001-9718-8887
  affiliations:
    - ref: witwatersrand
    
- name: "Justin E. Karr"
  orcid: 0000-0003-3653-332X
  affiliations:
    - ref: kentucky
    
- name: "Philippe Rast"
  orcid: 0000-0003-3630-6629
  affiliations:
    - ref: ucdavis
    
- name: "Catherine Draper*"
  orcid: 0000-0002-2885-437X
  affiliations:
    - ref: witwatersrand

- name: "Steven Howard*" 
  orcid: 0000-0002-1258-3210 
  affiliations: 
    - ref: oxford

- name: "Gaia Scerif*" 
  orcid: 0000-0002-6371-8874 
  affiliations: 
    - ref: oxford

affiliations: 
  - id: stanford 
    name: "Stanford University" 
  - id: oxford 
    name: "University of Oxford" 
  - id: witwatersrand 
    name: "University of the Witwatersrand"
  - id: kentucky
    name: "University of Kentucky"
  - id: ucdavis
    name: "University of California, Davis"

author-note: 
  disclosures: 
    financial-support: "This work was supported by X." 
    conflict-of-interest: "The author has no conflict of interest to declare."

abstract: TO BE ADDED.

keywords: ["executive function"] 
word-count: true

project:
  type: default
  
bibliography: library.bib

floatsintext: true
numbered-lines: true
# draft: false
mask: false

# figurelist: no
# tablelist: no
# footnotelist: no

format:
  apaquarto-pdf:
    documentmode: man
    keep-tex: true
    include-in-header: preamble.tex
    fig-format: png
    pdf-engine: xelatex
   
knitr:
  opts_chunk:
    ft.arraystretch: 1.25

execute:
  echo: false 
  message: false 
  warning: false 
  error: true 
  cache: true
---

# Introduction

\clearpage

# Methods

## Participants 
## Measures
## Statistical Analysis
### Edges weights
### Network estimation
### Global Strength
### Centrality

\clearpage

# Results

```{r}
#| label: packages
#| include: false
#| cache: false

library(tidyverse)
library(here)
library(glue)
library(purrr)
library(viridis)
library(flextable)
library(lavaan)
library(broom.mixed)
library(lmerTest)
library(png)
library(emmeans)
library(dplyr)
library(ggplot2)
library(stringr)
library(psych) 
library(tibble)
library(haven)
library(BGGM)
library(networktools)  
library(qgraph)
library(haven)
library(readxl)
library(tidyr)
library(readr)
library(gt)


if (requireNamespace("conflicted", quietly = TRUE)) {
  conflicted::conflicts_prefer(
    dplyr::select,
    dplyr::filter,
    dplyr::lag,
    dplyr::rename,
    tidyr::extract
  )
  options(conflicted.policy = "strict") 
}
```

```{r}
#| label: plot-helper
#| include: false

source(here::here("ef_network_plotting_helper.R"))
```

```{r}
#| label: load-aus-data
#| include: false
#| cache: false

aus_data <- read_sav("REDACTED")
colnames(aus_data)
# view(aus_data)
```

```{r}
#| label: load-sa-data
#| include: false
#| cache: false

# sa_data <- read_csv("REDACTED")

# Caylee's do file as text file
path <- "REDACTED"
system2("open", path)

do_lines <- read_lines("REDACTED")

idx <- which(str_detect(do_lines, "^\\s*import\\s+delimited\\b"))[1]
stopifnot(!is.na(idx))

line <- do_lines[idx]

# remove "import delimited", then keep the varlist (everything before " using ")
tmp <- line |>
  str_remove("^\\s*import\\s+delimited\\s+") |>
  str_split("\\s+using\\s+", n = 2, simplify = TRUE)

varlist <- tmp[1]  # everything before "using"

cols <- str_split(str_squish(varlist), "\\s+")[[1]]

sa_data <- read_csv(
  "REDACTED",
  col_names = FALSE
)

stopifnot(length(cols) == ncol(sa_data))
names(sa_data) <- cols

# checks
length(cols)
ncol(sa_data)

colnames(sa_data)
colnames(aus_data)

```

```{r}
#| label: derive-hle-vars
#| include: false

to_num <- function(x) suppressWarnings(as.numeric(as.character(x)))

# (1) HLA frequency (8 items: 0/1/2)
hla_freq_vars <- c(
  "hle_read_books", "hle_stories", "hle_songs", "hle_outside",
  "hle_play", "hle_names", "hle_count", "hle_draw"
)

# (2) Unique caregiver types across any activity (codes 1-6)
activities <- c("read", "stories", "songs", "outside", "play", "names", "count", "draw")
caregiver_codes <- 1:6

# (3) Books/toys total (4 items: 0/1)
books_toys_vars <- c(
  "hle_books_home", "hle_homemade_toys", "hle_toys_shop", "hle_household_objects"
)

# (4) Time total: week + weekend (each 1..3) 
time_vars <- c("hle_time_week", "hle_time_weekend")

# derive 1, 3 and 4 (NA only if ALL items missing; otherwise sum observed)
sa_data <- sa_data %>%
  dplyr::mutate(
    hla_frequency1 = dplyr::if_else(
      dplyr::if_all(dplyr::all_of(hla_freq_vars), is.na),
      NA_real_,
      rowSums(dplyr::across(dplyr::all_of(hla_freq_vars), to_num), na.rm = TRUE)
    ),
    books_toys_total1 = dplyr::if_else(
      dplyr::if_all(dplyr::all_of(books_toys_vars), is.na),
      NA_real_,
      rowSums(dplyr::across(dplyr::all_of(books_toys_vars), to_num), na.rm = TRUE)
    ),
    time_total1 = dplyr::if_else(
      dplyr::if_all(dplyr::all_of(time_vars), is.na),
      NA_real_,
      rowSums(dplyr::across(dplyr::all_of(time_vars), to_num), na.rm = TRUE)
    )
  )

# derive 2: num_caregivers
who_all <- as.vector(sapply(
  activities,
  function(a) paste0("hle_", a, "_who___", caregiver_codes)
))

who_mat <- sa_data %>% dplyr::select(dplyr::any_of(who_all)) %>% as.matrix()

all_missing_who <- if (ncol(who_mat) == 0) {
  rep(TRUE, nrow(sa_data))
} else {
  rowSums(!is.na(who_mat)) == 0
}

present_mat <- sapply(caregiver_codes, function(k) {
  cols_k <- paste0("hle_", activities, "_who___", k)
  X <- sa_data %>% dplyr::select(dplyr::any_of(cols_k)) %>% as.matrix()
  if (ncol(X) == 0) return(rep(FALSE, nrow(sa_data)))
  X[is.na(X)] <- 0
  rowSums(X) > 0
})

sa_data$num_caregivers <- rowSums(present_mat)
sa_data$num_caregivers[all_missing_who] <- NA_integer_

# # checks
# summary(sa_data$hla_frequency1)
# summary(sa_data$num_caregivers)
# summary(sa_data$books_toys_total1)
# summary(sa_data$time_total1)
# 
# # distributions
# table(sa_data$hla_frequency1, useNA = "ifany")
# table(sa_data$num_caregivers, useNA = "ifany")
# table(sa_data$books_toys_total1, useNA = "ifany")
# table(sa_data$time_total1, useNA = "ifany")
# 
# check: activities reported but "0 caregivers"
if (interactive()) {
  with(sa_data, table(num_caregivers > 0, hla_frequency1 == 0, useNA = "ifany"))
  with(sa_data, table(num_caregivers > 0, is.na(hla_frequency1), useNA = "ifany"))
}

sa_data <- sa_data %>%
  dplyr::mutate(
    num_caregivers_clean = dplyr::if_else(
      !is.na(hla_frequency1) & hla_frequency1 > 0 & num_caregivers == 0,
      NA_integer_,
      num_caregivers
    )
  )

sum(sa_data$hla_frequency1 > 0 & sa_data$num_caregivers == 0, na.rm = TRUE)
sum(sa_data$hla_frequency1 > 0 & is.na(sa_data$num_caregivers_clean), na.rm = TRUE) # n=84 with no caregiver info. reported.

```

```{r}
#| label: derive-nids-assets-score
#| include: false

asset_vars <- paste0("nids_items_", 1:26)

sa_data <- sa_data %>%
  dplyr::mutate(
    # re-code asset items: set refuse/don't know (3/4) to NA, otherwise keep integer
    dplyr::across(
      dplyr::all_of(asset_vars),
      ~ dplyr::if_else(.x %in% c(3L, 4L), NA_integer_, as.integer(.x))
    ),

    # diagnostics: number answered (non-missing) across the 26 items
    n_assets_answered = rowSums(!is.na(as.matrix(dplyr::pick(dplyr::all_of(asset_vars))))),

    # score: count "Yes" (== 1) across items, but only if >= 20 answered
    household_items_score_repl = dplyr::if_else(
      n_assets_answered < 20,
      NA_real_,
      rowSums(as.matrix(dplyr::pick(dplyr::all_of(asset_vars)) == 1L), na.rm = TRUE)
    )
  )

# quick check vs existing score (if present)
cor(sa_data$household_items_score, sa_data$household_items_score_repl,
    use = "pairwise.complete.obs")

sum(!is.na(sa_data$household_items_score) & !is.na(sa_data$household_items_score_repl) &
      sa_data$household_items_score != sa_data$household_items_score_repl)

# optional: inspect threshold behaviour
table(sa_data$n_assets_answered < 20, useNA = "ifany")
summary(sa_data$household_items_score_repl)


```

```{r}
#| label: setup-helpers
#| include: false

library(gt)
# Formatting helpers
fmt_mean_sd <- function(mean, sd, digits = 2) {
  ifelse(
    is.na(mean) | is.na(sd),
    NA_character_,
    sprintf(paste0("%.", digits, "f (%.", digits, "f)"), mean, sd)
  )
}

fmt_med_rng <- function(median, min, max, digits = 2) {
  ifelse(
    is.na(median) | is.na(min) | is.na(max),
    NA_character_,
    sprintf(paste0("%.", digits, "f [%.", digits, "f, %.", digits, "f]"),
            median, min, max)
  )
}

# Continuous descriptives within EF-anchored sample (generic)
summ_cont_tp <- function(df, var, any_ids, variable_label) {
  stopifnot(all(c("country","timepoint","id") %in% names(df)))
  stopifnot(all(c("country","timepoint","id") %in% names(any_ids)))
  stopifnot(var %in% names(df))

  df %>%
    inner_join(distinct(any_ids, country, timepoint, id),
               by = c("country","timepoint","id")) %>%
    transmute(country, timepoint, id, x = as.numeric(.data[[var]])) %>%
    group_by(country, timepoint) %>%
    summarise(
      n      = sum(!is.na(x)),
      mean   = ifelse(all(is.na(x)), NA_real_, mean(x, na.rm = TRUE)),
      sd     = ifelse(sum(!is.na(x)) > 1, sd(x, na.rm = TRUE), NA_real_),
      median = ifelse(all(is.na(x)), NA_real_, median(x, na.rm = TRUE)),
      min    = ifelse(all(is.na(x)), NA_real_, min(x, na.rm = TRUE)),
      max    = ifelse(all(is.na(x)), NA_real_, max(x, na.rm = TRUE)),
      .groups = "drop"
    ) %>%
    mutate(variable = variable_label)
}

# Table helper 
# EF descriptives (expects standard long format)
# ef_long: country, timepoint, id, variable, value
# any_ids: country, timepoint, id
summ_ef_desc <- function(ef_long, any_ids) {
  stopifnot(all(c("country","timepoint","id","variable","value") %in% names(ef_long)))
  stopifnot(all(c("country","timepoint","id") %in% names(any_ids)))

  ef_long %>%
    inner_join(distinct(any_ids, country, timepoint, id),
               by = c("country","timepoint","id")) %>%
    group_by(country, timepoint, variable) %>%
    summarise(
      n      = sum(!is.na(value)),
      mean   = ifelse(all(is.na(value)), NA_real_, mean(value, na.rm = TRUE)),
      sd     = ifelse(sum(!is.na(value)) > 1, sd(value, na.rm = TRUE), NA_real_),
      median = ifelse(all(is.na(value)), NA_real_, median(value, na.rm = TRUE)),
      min    = ifelse(all(is.na(value)), NA_real_, min(value, na.rm = TRUE)),
      max    = ifelse(all(is.na(value)), NA_real_, max(value, na.rm = TRUE)),
      .groups = "drop"
    )
}

# Sample sizes + EF completeness within anchored sample
summ_sizes <- function(ef_long, any_ids, n_measures_complete = 3) {
  stopifnot(all(c("country","timepoint","id") %in% names(any_ids)))
  stopifnot(all(c("country","timepoint","id","variable","value") %in% names(ef_long)))

  ef_long_anch <- ef_long %>%
    inner_join(distinct(any_ids, country, timepoint, id),
               by = c("country","timepoint","id"))

  complete_by_child <- ef_long_anch %>%
    distinct(country, timepoint, id, variable, .keep_all = TRUE) %>%
    group_by(country, timepoint, id) %>%
    summarise(n_nonmiss_measures = sum(!is.na(value)), .groups = "drop")

  complete_by_child %>%
    group_by(country, timepoint) %>%
    summarise(
      n_children_any_ef = n_distinct(id),
      n_complete_ef     = sum(n_nonmiss_measures >= n_measures_complete),
      pct_complete_ef   = round(100 * mean(n_nonmiss_measures >= n_measures_complete), 1),
      .groups = "drop"
    )
}

# Age descriptives within EF-anchored sample
summ_age_long <- function(age_long, any_ids) {
  stopifnot(all(c("country","timepoint","id") %in% names(any_ids)))
  stopifnot(all(c("country","timepoint","id","age") %in% names(age_long)))

  age_long %>%
    inner_join(distinct(any_ids, country, timepoint, id),
               by = c("country","timepoint","id")) %>%
    mutate(age = as.numeric(age)) %>%
    group_by(country, timepoint) %>%
    summarise(
      age_n      = sum(!is.na(age)),
      age_mean   = ifelse(age_n > 0, mean(age, na.rm = TRUE), NA_real_),
      age_sd     = ifelse(age_n > 1, sd(age, na.rm = TRUE), NA_real_),
      age_median = ifelse(age_n > 0, median(age, na.rm = TRUE), NA_real_),
      age_min    = ifelse(age_n > 0, min(age, na.rm = TRUE), NA_real_),
      age_max    = ifelse(age_n > 0, max(age, na.rm = TRUE), NA_real_),
      .groups = "drop"
    )
}

# categorical descriptives by timepoint (those with any EF data)
desc_cat_tp <- function(df, var, any_ids, variable_label) {
  stopifnot(all(c("country","timepoint","id") %in% names(df)))
  stopifnot(all(c("country","timepoint","id") %in% names(any_ids)))
  stopifnot(var %in% names(df))

  df %>%
    inner_join(distinct(any_ids, country, timepoint, id),
               by = c("country","timepoint","id")) %>%
    distinct(country, timepoint, id, .data[[var]]) %>%
    count(country, timepoint, .data[[var]], name = "n") %>%
    group_by(country, timepoint) %>%
    mutate(pct = 100 * n / sum(n)) %>%
    ungroup() %>%
    transmute(
      country,
      timepoint,
      variable = variable_label,
      level    = as.character(.data[[var]]),
      cell     = paste0(n, " (", sprintf("%.1f", pct), "%)")
    )
}

# Sex
harmonise_sex_sa <- function(x) {
  x <- as.character(x)
  out <- dplyr::case_when(
    is.na(x) | x == "" ~ "Missing",
    x == "0" ~ "Female",   # swap if codebook says 0=Male
    x == "1" ~ "Male",
    TRUE ~ "Other/Unknown"
  )
  factor(out, levels = c("Female","Male","Other/Unknown","Missing"))
}

harmonise_sex_aus <- function(x) {
  x <- as.character(x)
  out <- dplyr::case_when(
    is.na(x) | x == "" ~ "Missing",
    x == "1" ~ "Male",     # swap if codebook says 1=Female
    x == "2" ~ "Female",
    TRUE ~ "Other/Unknown"
  )
  factor(out, levels = c("Female","Male","Other/Unknown","Missing"))
}

```

```{r}
#| label: build-sa-aus-objects
#| include: false

# SA: subset -> long -> anchor -> standard long objects
eyt_vars <- c(
  "date_of_eyt", "eyt_child_age_at_testing", "eyt2_ageinmonths", "time_btwn_testing",
  "ef_inhibition", "ef_cogflex", "ef_workingmem",
  "refuse_missing_eyt", "notes_eyt", "early_years_toolbox_complete"
)

ses_vars <- c(
  # NIDS / income-related
  "nids_income_1", "nids_income_2", "nids_income_3",
  "nids_income_4", "nids_income_5", "nids_income_6",
  "income_range", "monthly_income_given",

  # NIDS assets-derived score
  "household_items_score_repl",

  # education etc
  "marital_status", "education_school", "education_post_school", "education_post_school_b",
  "children_in_house", "adults_in_house", "total_in_household",

  # HLE derived vars
  "hla_frequency1", "num_caregivers_clean", "books_toys_total1", "time_total1"
)

id_vars <- c(
  "caregiver_child_studyid", "redcap_event_name", "interview_date",
  "ra", "child_id", "caregiver_id",
  "child_sex", "child_dob", "child_age", "child_birthweight",
  "caregiver_dob", "caregiver_age", "relationship_child",
  "child_education", "child_education_specific", "child_education_frequency"
)

sa_subset_long <- sa_data %>%
  dplyr::select(dplyr::any_of(c(id_vars, ses_vars, eyt_vars))) %>%
  dplyr::distinct(caregiver_child_studyid, redcap_event_name, .keep_all = TRUE)

ef_sa <- c("ef_inhibition", "ef_cogflex", "ef_workingmem")

# Anchor: child×event where ANY EF node observed
sa_any_ef_ids_by_tp <- sa_subset_long %>%
  dplyr::filter(dplyr::if_any(dplyr::all_of(ef_sa), ~ !is.na(.x))) %>%
  dplyr::distinct(redcap_event_name, caregiver_child_studyid)

sa_tp_map <- sa_subset_long %>%
  dplyr::distinct(redcap_event_name) %>%
  dplyr::mutate(
    timepoint = dplyr::case_when(
      redcap_event_name == "data_collection_20_arm_1"  ~ "T1",
      redcap_event_name == "data_collection_20_arm_1b" ~ "T2",
      TRUE ~ NA_character_
    )
  ) %>%
  dplyr::filter(!is.na(timepoint)) %>%
  dplyr::select(redcap_event_name, timepoint)

# optional: assert you got exactly 2 timepoints
stopifnot(nrow(sa_tp_map) == 2)
stopifnot(all(c("T1","T2") %in% sa_tp_map$timepoint))

# Sex long (wave-level)
sa_sex_long <- sa_subset_long %>%
  dplyr::left_join(sa_tp_map, by = "redcap_event_name") %>%
  dplyr::transmute(
    country   = "SA",
    timepoint = timepoint,
    id        = caregiver_child_studyid,
    sex       = harmonise_sex_sa(child_sex)
  )

# standardized anchor ids: country,timepoint,id (EF-anchored)
sa_any_ids <- sa_any_ef_ids_by_tp %>%
  dplyr::left_join(sa_tp_map, by = "redcap_event_name") %>%
  dplyr::transmute(country = "SA", timepoint, id = caregiver_child_studyid)

# SA EF long (standard; EF-anchored)
sa_ef_long <- sa_subset_long %>%
  dplyr::inner_join(sa_any_ef_ids_by_tp, by = c("redcap_event_name","caregiver_child_studyid")) %>%
  dplyr::left_join(sa_tp_map, by = "redcap_event_name") %>%
  dplyr::transmute(
    country   = "SA",
    timepoint = timepoint,
    id        = caregiver_child_studyid,
    dplyr::across(dplyr::all_of(ef_sa), as.numeric)
  ) %>%
  tidyr::pivot_longer(cols = dplyr::all_of(ef_sa), names_to = "variable", values_to = "value") %>%
  dplyr::select(country, timepoint, id, variable, value)

# SA age long (standard, not EF-anchored here)
sa_age_long <- sa_subset_long %>%
  dplyr::left_join(sa_tp_map, by = "redcap_event_name") %>%
  dplyr::transmute(
    country   = "SA",
    timepoint = timepoint,
    id        = caregiver_child_studyid,
    age       = as.numeric(child_age)
  )

# SA SES long (standard; not EF-anchored here)
sa_ses <- sa_subset_long %>%
  dplyr::left_join(sa_tp_map, by = "redcap_event_name") %>%
  dplyr::transmute(
    country   = "SA",
    timepoint = timepoint,
    id        = caregiver_child_studyid,

    edu_sa = dplyr::if_else(
      education_post_school == 1,
      as.integer(education_post_school_b),
      NA_integer_
    ),

    nids_assets_sa = as.numeric(household_items_score_repl),

    hla_frequency1       = as.numeric(hla_frequency1),
    num_caregivers_clean = as.numeric(num_caregivers_clean),
    books_toys_total1    = as.numeric(books_toys_total1),
    time_total1          = as.numeric(time_total1)
  )


# AUS: wide -> standard EF long + anchors + age + SES
id_var <- if ("CID" %in% names(aus_data)) "CID" else "ServiceID"

t1_vars <- c("MrAnt_Pt_T1","GNG_IC_T1","CS_SwAcc_T1")
t2_vars <- c("MrAnt_Pt_T2","GNG_IC_T2","CS_SwAcc_T2")
t3_vars <- c("MrAnt_Pt_T3","GNG_IC_T3","CS_SwAcc_T3")
ef_vars <- c(t1_vars, t2_vars, t3_vars)

stopifnot(all(ef_vars %in% names(aus_data)))

aus_ef_long <- aus_data %>%
  dplyr::mutate(id = as.character(.data[[id_var]])) %>%
  dplyr::filter(!is.na(id)) %>%
  dplyr::select(id, dplyr::all_of(ef_vars)) %>%
  tidyr::pivot_longer(
    cols = -id,
    names_to = c("measure", "wave"),
    names_pattern = "^(.*)_T([123])$",
    values_to = "value"
  ) %>%
  dplyr::mutate(
    country   = "AU",
    timepoint = paste0("T", wave),
    variable  = dplyr::recode(measure,
      "MrAnt_Pt" = "ef_workingmem",
      "GNG_IC"   = "ef_inhibition",
      "CS_SwAcc" = "ef_cogflex"
    ),
    value = as.numeric(value)
  ) %>%
  dplyr::select(country, timepoint, id, variable, value)

aus_any_ids <- aus_ef_long %>%
  dplyr::group_by(country, timepoint, id) %>%
  dplyr::summarise(any_ef = any(!is.na(value)), .groups = "drop") %>%
  dplyr::filter(any_ef) %>%
  dplyr::select(country, timepoint, id)

stopifnot(all(c("Age_T1","Age_T2","Age_T3") %in% names(aus_data)))

aus_age_long <- aus_data %>%
  dplyr::mutate(id = as.character(.data[[id_var]])) %>%
  dplyr::filter(!is.na(id)) %>%
  dplyr::select(id, Age_T1, Age_T2, Age_T3) %>%
  tidyr::pivot_longer(cols = dplyr::starts_with("Age_T"), names_to = "timepoint", values_to = "age") %>%
  dplyr::mutate(
    country   = "AU",
    timepoint = gsub("^Age_", "", timepoint),
    age       = as.numeric(age)
  ) %>%
  dplyr::select(country, timepoint, id, age)

# Sex
sex_var_aus <- if ("Sex" %in% names(aus_data)) {
  "Sex"
} else if ("sex" %in% names(aus_data)) {
  "sex"
} else {
  stop("Couldn't find sex variable in aus_data (expected sex or Sex).")
}

aus_sex_child <- aus_data %>%
  dplyr::mutate(id = as.character(.data[[id_var]])) %>%
  dplyr::filter(!is.na(id)) %>%
  dplyr::distinct(id, .keep_all = TRUE) %>%
  dplyr::transmute(
    country = "AU",
    id,
    sex = harmonise_sex_aus(.data[[sex_var_aus]])
  )

table(sa_data$child_sex, useNA="ifany")
table(harmonise_sex_sa(sa_data$child_sex), useNA="ifany")

table(aus_data[[sex_var_aus]], useNA="ifany")
table(harmonise_sex_aus(aus_data[[sex_var_aus]]), useNA="ifany")

aus_sex_tp <- aus_any_ids %>%
  dplyr::left_join(aus_sex_child, by = c("country","id"))

# child-level SES + HLE
stopifnot(all(c("A2_MatEdu","A3_FamIncome") %in% names(aus_data)))

aus_ses_child <- aus_data %>%
  dplyr::mutate(id = as.character(.data[[id_var]])) %>%
  dplyr::filter(!is.na(id)) %>%
  dplyr::distinct(id, .keep_all = TRUE) %>%
  dplyr::transmute(
    country    = "AU",
    id,
    edu_aus    = as.integer(A2_MatEdu),
    income_aus = as.character(A3_FamIncome),
    hle_aus    = as.numeric(HLE_Index)
  )

# expand across EF-anchored timepoints
aus_ses_tp <- aus_any_ids %>%
  dplyr::left_join(aus_ses_child, by = c("country","id"))

```

```{r}
#| label: build-ef-age-objects
#| include: false

stopifnot(exists("sa_ef_long"), exists("aus_ef_long"))
stopifnot(exists("sa_age_long"), exists("aus_age_long"))
# stopifnot(exists("sa_sex_long"), exists("aus_sex_tp"))

time_levels <- c("T1","T2","T3")
nodes <- c("ef_inhibition","ef_cogflex","ef_workingmem")

# helper: keep timepoints by country (SA only T1/T2; AU T1/T2/T3)
keep_ct_tp <- function(country, timepoint) {
  (country == "SA" & timepoint %in% c("T1","T2")) |
  (country == "AU" & timepoint %in% c("T1","T2","T3"))
}

# EF long combined
ef_all <- dplyr::bind_rows(
  sa_ef_long  %>% dplyr::mutate(id = as.character(id)),
  aus_ef_long %>% dplyr::mutate(id = as.character(id))
) %>%
  dplyr::mutate(
    timepoint = factor(as.character(timepoint), levels = time_levels, ordered = TRUE),
    variable  = factor(as.character(variable),  levels = nodes)
  )

# Age long combined
age_all <- dplyr::bind_rows(
  sa_age_long  %>% dplyr::mutate(id = as.character(id)),
  aus_age_long %>% dplyr::mutate(id = as.character(id))
) %>%
  dplyr::mutate(
    timepoint = factor(as.character(timepoint), levels = time_levels, ordered = TRUE),
    age       = as.numeric(age)
  )

# sex combined (already wave-level in pipeline)
# sex_all_tp <- dplyr::bind_rows(
#   sa_sex_long %>% dplyr::select(country, timepoint, id, sex),
#   aus_sex_tp  %>% dplyr::select(country, timepoint, id, sex)
# ) %>%
#   dplyr::mutate(
#     timepoint = factor(as.character(timepoint), levels = time_levels, ordered = TRUE),
#     id        = as.character(id)
#   )

# apply country-specific timepoint rule
ef_all_keep <- ef_all %>%
  dplyr::filter(keep_ct_tp(country, timepoint))

age_all_keep <- age_all %>%
  dplyr::filter(keep_ct_tp(country, timepoint))

# sex_all_tp_keep <- sex_all_tp %>%
#   dplyr::filter(keep_ct_tp(country, timepoint))

#  check
stopifnot(all(levels(ef_all_keep$variable) == nodes))

```

```{r}
#| label: step0-data-prep
#| include: false

# Prepare EF node data for BGGM:
# - keep partial EF (no complete-case filtering)
# - drop cohort×wave IDs with all 3 nodes missing
# - residualize each node for age within cohort×wave
# - z-score residuals within cohort×wave×node
# - pivot wide for BGGM

stopifnot(exists("ef_all_keep"), exists("age_all_keep")) 
stopifnot(exists("nodes"))

# helper for within-group z-score
z_within <- function(x) {
  m <- mean(x, na.rm = TRUE)
  s <- stats::sd(x, na.rm = TRUE)
  if (is.na(s) || s == 0) return(rep(NA_real_, length(x)))
  (x - m) / s
}

# join covariate (age) + restrict to EF nodes
ef_net0 <- ef_all_keep %>%
  dplyr::filter(as.character(variable) %in% nodes) %>%
  dplyr::left_join(
    age_all_keep %>% dplyr::select(country, timepoint, id, age),
    by = c("country","timepoint","id")
  ) %>%
  dplyr::mutate(
    id    = as.character(id),
    age   = as.numeric(age),
    value = as.numeric(value)
  ) %>%
  dplyr::filter(!is.na(age)) # controlling for age only (not sex)

# check duplicates before pivot_wider 
dup_check <- ef_net0 %>%
  dplyr::count(country, timepoint, id, variable, name = "n") %>%
  dplyr::filter(n > 1)

stopifnot(nrow(dup_check) == 0)

# drop cohort×wave IDs with all three nodes missing
ef_any_ids <- ef_net0 %>%
  dplyr::group_by(country, timepoint, id) %>%
  dplyr::summarise(any_node_observed = any(!is.na(value)), .groups = "drop") %>%
  dplyr::filter(any_node_observed) %>%
  dplyr::select(country, timepoint, id)

ef_net0 <- ef_net0 %>%
  dplyr::inner_join(ef_any_ids, by = c("country","timepoint","id"))

# residualize within cohort×wave×node (observed values only), then z-score residuals
residise_one <- function(d) {
  d <- dplyr::mutate(d, .rid = dplyr::row_number())
  obs <- dplyr::filter(d, !is.na(value))

  if (nrow(obs) < 10) {
    d$resid <- NA_real_
    return(dplyr::select(d, -.rid))
  }

  fit <- stats::lm(value ~ age, data = obs)
  obs <- dplyr::mutate(obs, resid = stats::residuals(fit))

  d <- dplyr::left_join(d, dplyr::select(obs, .rid, resid), by = ".rid")
  dplyr::select(d, -.rid)
}

ef_net <- ef_net0 %>%
  dplyr::group_by(country, timepoint, variable) %>%
  dplyr::group_modify(~ residise_one(.x)) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(country, timepoint, variable) %>%
  dplyr::mutate(node = ifelse(is.na(resid), NA_real_, z_within(resid))) %>%
  dplyr::ungroup()

# check if residualization wiped an entire node within cohort×wave
node_obs_check <- ef_net %>%
  dplyr::group_by(country, timepoint, variable) %>%
  dplyr::summarise(n_obs = sum(!is.na(node)), .groups = "drop")

stopifnot(all(node_obs_check$n_obs > 0))

# wide matrix per cohort×wave for BGGM
ef_net_wide <- ef_net %>%
  dplyr::select(country, timepoint, id, variable, node) %>%
  tidyr::pivot_wider(
    names_from = variable,
    values_from = node
  ) %>%
  dplyr::filter(!dplyr::if_all(dplyr::all_of(nodes), ~ is.na(.)))

# within-wave missingness vs attrition diagnostics
missingness_ct <- ef_net_wide %>%
  dplyr::group_by(country, timepoint) %>%
  dplyr::summarise(
    n          = dplyr::n(),
    missing_cells = sum(is.na(as.matrix(dplyr::pick(dplyr::all_of(nodes))))),
    total_cells   = dplyr::n() * length(nodes),
    pct_missing   = 100 * missing_cells / total_cells,
    .groups = "drop"
  )

# align draws helper
align_draws <- function(x, y, keep = c("last","first")) {
  keep <- match.arg(keep)
  n <- min(length(x), length(y))
  if (keep == "last") list(x = tail(x, n), y = tail(y, n))
  else                list(x = head(x, n), y = head(y, n))
}
```

```{r}
#| label: step_1a-fit-bggm
#| include: false

stopifnot(exists("ef_net_wide"))
stopifnot(all(c("country","timepoint","id", nodes) %in% names(ef_net_wide)))

bggm_post   <- 5000
bggm_burnin <- 50
bggm_iter   <- bggm_post + bggm_burnin
bggm_chains <- 1

dat_split <- ef_net_wide %>%
  dplyr::select(country, timepoint, id, dplyr::all_of(nodes)) %>%
  dplyr::group_by(country, timepoint) %>%
  dplyr::group_split()

keys <- ef_net_wide %>%
  dplyr::select(country, timepoint, id, dplyr::all_of(nodes)) %>%
  dplyr::group_by(country, timepoint) %>%
  dplyr::group_keys() %>%
  dplyr::arrange(country, timepoint)

stopifnot(nrow(keys) == length(dat_split))

fit_one <- function(df) {

  Y <- df %>%
    dplyr::select(dplyr::all_of(nodes)) %>%
    dplyr::mutate(dplyr::across(dplyr::everything(), as.numeric)) %>%
    as.matrix()

  n <- nrow(Y)
  p <- ncol(Y)
  miss_cells <- sum(is.na(Y))
  total_cells <- length(Y)
  pct_missing <- 100 * miss_cells / total_cells

  # if too small for the model, return null fit but keep diagnostics
  if (n < 10) {
    return(list(
      fit = NULL,
      n = n,
      missing_cells = miss_cells,
      total_cells = total_cells,
      pct_missing = pct_missing
    ))
  }

  fit <- BGGM::estimate(
    Y,
    type   = "continuous",
    iter   = bggm_iter,
    burnin = bggm_burnin,
    chains = bggm_chains,
    impute = TRUE,
    save   = TRUE
  )

  list(
    fit = fit,
    n = n,
    missing_cells = miss_cells,
    total_cells = total_cells,
    pct_missing = pct_missing
  )
}

ggm_fits_step1 <- purrr::map(dat_split, fit_one)

fit_tbl <- keys %>%
  dplyr::mutate(res = ggm_fits_step1) %>%
  tidyr::unnest_wider(res)

# check fit
fit_tbl %>%
  dplyr::mutate(ok = !purrr::map_lgl(fit, is.null)) %>%
  dplyr::select(country, timepoint, n, missing_cells, total_cells, pct_missing, ok)
fit_tbl

```

```{r}
#| label: net-helpers
#| include: false

edge_draws_list <- function(fit, node_names = nodes) {
  A <- fit$post_samp$pcors  # [p x p x S]
  p <- dim(A)[1]
  stopifnot(length(node_names) == p)

  # enforce names
  dimnames(A) <- list(node_names, node_names, NULL)

  idx <- which(upper.tri(matrix(FALSE, p, p)), arr.ind = TRUE)

  out <- vector("list", nrow(idx))
  nms <- character(nrow(idx))

  for (i in seq_len(nrow(idx))) {
    a <- idx[i, 1]; b <- idx[i, 2]
    out[[i]] <- A[a, b, ]
    nms[i] <- paste0(node_names[a], " — ", node_names[b])
  }
  names(out) <- nms
  out
}

global_strength_draws <- function(fit, absolute = TRUE) {
  A <- fit$post_samp$pcors  # [p x p x S]
  p <- dim(A)[1]
  S <- dim(A)[3]
  ut <- upper.tri(matrix(FALSE, p, p))

  sapply(seq_len(S), function(s) {
    M <- A[, , s]
    if (absolute) M <- abs(M)
    sum(M[ut])
  })
}

expected_influence_draws <- function(fit, node_names = nodes) {
  A <- fit$post_samp$pcors   # [p x p x S]
  p <- dim(A)[1]
  S <- dim(A)[3]
  stopifnot(length(node_names) == p)

  # enforce node names
  dimnames(A) <- list(node_names, node_names, NULL)

  # EI per node per draw: S x p (signed sum of incident edges; excludes diagonal)
  EI <- vapply(seq_len(S), function(s) {
    M <- A[, , s]
    rowSums(M, na.rm = TRUE) - diag(M)
  }, FUN.VALUE = numeric(p))

  EI <- t(EI)              # S x p
  colnames(EI) <- node_names
  EI
}

ei_summaries <- function(fit, node_names = nodes, probs = c(.025, .5, .975)) {
  EI <- expected_influence_draws(fit, node_names = node_names)  # S x p
  tibble::tibble(
    node = colnames(EI),
    q025 = apply(EI, 2, stats::quantile, probs[1], na.rm = TRUE),
    q50  = apply(EI, 2, stats::quantile, probs[2], na.rm = TRUE),
    q975 = apply(EI, 2, stats::quantile, probs[3], na.rm = TRUE)
  )
}

```

```{r}
#| label: report-edge-summaries
#| include: false

edge_summaries <- function(fit, probs = c(.025, .5, .975), node_names = nodes) {
  A <- fit$post_samp$pcors  # [p x p x S]
  p <- dim(A)[1]

  # enforce node names 
  stopifnot(length(node_names) == p)
  dimnames(A) <- list(node_names, node_names, NULL)
  nm <- node_names

  # upper-triangle indices
  idx <- which(upper.tri(matrix(FALSE, p, p)), arr.ind = TRUE)

  purrr::map_dfr(seq_len(nrow(idx)), function(i) {
    a <- idx[i, 1]; b <- idx[i, 2]
    draws <- A[a, b, ]
    qs <- stats::quantile(draws, probs = probs, na.rm = TRUE)

    tibble::tibble(
      node1 = nm[a],
      node2 = nm[b],
      q025  = unname(qs[1]),
      q50   = unname(qs[2]),
      q975  = unname(qs[3]),
      ci_excludes_0 = !(unname(qs[1]) <= 0 & unname(qs[3]) >= 0)
    )
  })
}

edge_tbl <- fit_tbl %>%
  dplyr::filter(!purrr::map_lgl(fit, is.null)) %>%
  dplyr::mutate(edges = purrr::map(fit, edge_summaries)) %>%
  tidyr::unnest(edges) %>%
  dplyr::mutate(
    edge = vapply(
    Map(c, node1, node2),
    function(z) paste(sort(unlist(z)), collapse = " - "),
    character(1)
  )
)

```

```{r}
#| label: report-global-strength
#| include: false
#| 
gs_tbl <- fit_tbl %>%
  dplyr::filter(!purrr::map_lgl(fit, is.null)) %>%
  dplyr::mutate(
    gs_draws = purrr::map(fit, global_strength_draws),
    q025 = purrr::map_dbl(gs_draws, ~ stats::quantile(.x, .025, na.rm = TRUE)),
    q50  = purrr::map_dbl(gs_draws, ~ stats::quantile(.x, .50,  na.rm = TRUE)),
    q975 = purrr::map_dbl(gs_draws, ~ stats::quantile(.x, .975, na.rm = TRUE))
  ) %>%
  dplyr::select(country, timepoint, q025, q50, q975)

```

```{r}
#| label: report-posterior-difference-scores
#| include: false

edge_diff <- function(fit_A, fit_B) {
  A <- fit_A$post_samp$pcors
  B <- fit_B$post_samp$pcors

  # align draw counts 
  S <- min(dim(A)[3], dim(B)[3])
  A <- A[, , (dim(A)[3] - S + 1):dim(A)[3], drop = FALSE]
  B <- B[, , (dim(B)[3] - S + 1):dim(B)[3], drop = FALSE]

  D <- A - B # posterior draws of differences

  p <- dim(D)[1]
  edges <- which(upper.tri(matrix(NA, p, p)), arr.ind = TRUE)

  purrr::map_dfr(seq_len(nrow(edges)), function(i) {
    a <- edges[i, 1]; b <- edges[i, 2]
    draws <- D[a, b, ]
    qs <- quantile(draws, c(.025, .5, .975), na.rm = TRUE)
    tibble::tibble(
      node1 = dimnames(D)[[1]][a],
      node2 = dimnames(D)[[2]][b],
      diff_q025 = unname(qs[1]),
      diff_q50  = unname(qs[2]),
      diff_q975 = unname(qs[3]),
      diff_sig  = !(qs[1] <= 0 && qs[3] >= 0)  # CI excludes 0
    )
  })
}

fit_AU_T1 <- fit_tbl %>% dplyr::filter(country=="AU", timepoint=="T1") %>% dplyr::pull(fit) %>% .[[1]]
fit_SA_T1 <- fit_tbl %>% dplyr::filter(country=="SA", timepoint=="T1") %>% dplyr::pull(fit) %>% .[[1]]

edge_diff_AUvsSA_T1 <- edge_diff(fit_AU_T1, fit_SA_T1)
```

```{r}
#| label: report-global-strength-difference-scores
#| include: false

gs_diff <- function(fit_A, fit_B) {
  gsA <- global_strength_draws(fit_A)
  gsB <- global_strength_draws(fit_B)
  S <- min(length(gsA), length(gsB))
  gsA <- tail(gsA, S); gsB <- tail(gsB, S)
  d <- gsA - gsB
  tibble::tibble(
    diff_mean = mean(d),
    diff_q025 = quantile(d, .025),
    diff_q975 = quantile(d, .975),
    diff_sig  = !(quantile(d, .025) <= 0 && quantile(d, .975) >= 0)
  )
}
```

```{r}
#| label: report-missingness
#| include: false

missingness_ct <- purrr::map2_dfr(dat_split, keys$country, function(df, cc) {
   NULL
})

missingness_ct <- purrr::map2_dfr(dat_split, seq_len(nrow(keys)), function(df, i) {
  Y <- df %>%
    dplyr::select(dplyr::all_of(nodes)) %>%
    dplyr::mutate(dplyr::across(dplyr::everything(), as.numeric)) %>%
    as.matrix()

  tibble::tibble(
    country       = keys$country[i],
    timepoint     = keys$timepoint[i],
    n             = nrow(Y),
    missing_cells = sum(is.na(Y)),
    total_cells   = length(Y),
    pct_missing   = 100 * sum(is.na(Y)) / length(Y)
  )
})
missingness_ct
```

```{r}
#| label: rq1-tables
#| include: false

rope <- 0.10  

# helpers
fmt_ci <- function(m, lo, hi, digits = 2) {
  sprintf(paste0("%.", digits, "f [%.", digits, "f, %.", digits, "f]"), m, lo, hi)
}
fmt_p <- function(p, digits = 2) sprintf(paste0("%.", digits, "f"), p)

summ_draws <- function(draws, rope = 0.10) {
  qs <- stats::quantile(draws, c(.025, .5, .975), na.rm = TRUE)
  tibble::tibble(
    q025 = unname(qs[1]),
    q50  = unname(qs[2]),
    q975 = unname(qs[3]),
    p_outside_rope = mean(abs(draws) > rope, na.rm = TRUE)
  )
}

# guardrails: ensure you're not silently relying on deleted duplicates
stopifnot(exists("edge_draws_list"))
stopifnot(exists("global_strength_draws"))
stopifnot(exists("ei_summaries"))
stopifnot(exists("fit_tbl"))
stopifnot(exists("nodes"))

# one row per cohort×wave
fit_tbl_uniq <- fit_tbl %>%
  dplyr::filter(!purrr::map_lgl(fit, is.null)) %>%
  dplyr::arrange(country, timepoint) %>%
  dplyr::group_by(country, timepoint) %>%
  dplyr::slice(1) %>%
  dplyr::ungroup()

# edges
rq1_edges <- fit_tbl_uniq %>%
  dplyr::transmute(country, timepoint, n, pct_missing, fit) %>%
  dplyr::mutate(edge_list = purrr::map(fit, ~ edge_draws_list(.x, node_names = nodes))) %>%
  dplyr::mutate(edge_df   = purrr::map(edge_list, ~ tibble::tibble(edge = names(.x), draws = unname(.x)))) %>%
  tidyr::unnest(edge_df) %>%
  dplyr::mutate(stats = purrr::map(draws, ~ summ_draws(.x, rope = rope))) %>%
  tidyr::unnest(stats) %>%
  dplyr::transmute(
    country, timepoint, n, pct_missing,
    edge,
    estimate = fmt_ci(q50, q025, q975, digits = 2),
    rope_p   = fmt_p(p_outside_rope, digits = 2)
  ) %>%
  # canonicalise edge names so ordering is consistent everywhere
  dplyr::mutate(
    edge = vapply(
      strsplit(edge, " — ", fixed = TRUE),
      function(z) paste(sort(z), collapse = " - "),
      character(1)
    )
  )

# global strength
rq1_gs <- fit_tbl_uniq %>%
  dplyr::transmute(country, timepoint, n, pct_missing, fit) %>%
  dplyr::mutate(gs_draws = purrr::map(fit, global_strength_draws)) %>%
  dplyr::mutate(stats = purrr::map(gs_draws, ~ {
    qs <- stats::quantile(.x, c(.025, .5, .975), na.rm = TRUE)
    tibble::tibble(q025 = unname(qs[1]), q50 = unname(qs[2]), q975 = unname(qs[3]))
  })) %>%
  tidyr::unnest(stats) %>%
  dplyr::transmute(
    country, timepoint, n, pct_missing,
    edge     = "Global strength",
    estimate = fmt_ci(q50, q025, q975, digits = 2),
    rope_p   = NA_character_
  )

rq1_table_A <- dplyr::bind_rows(rq1_gs, rq1_edges) %>%
  dplyr::mutate(
    rope_p = dplyr::if_else(edge == "Global strength", "", rope_p)
  ) %>%
  dplyr::arrange(country, timepoint, dplyr::desc(edge == "Global strength"), edge)

# hard check: 4 rows per cohort×wave (3 edges + global strength)
stopifnot(all((rq1_table_A %>% dplyr::count(country, timepoint) %>% dplyr::pull(n)) == 4))

# expected influence (node-level)
rq1_table_B <- fit_tbl_uniq %>%
  dplyr::transmute(country, timepoint, n, pct_missing, fit) %>%
  dplyr::mutate(ei = purrr::map(fit, ~ ei_summaries(.x, node_names = nodes))) %>%
  tidyr::unnest(ei) %>%
  dplyr::transmute(
    country, timepoint, n, pct_missing,
    node,
    estimate = fmt_ci(q50, q025, q975, digits = 2)
  ) %>%
  dplyr::arrange(country, timepoint, node)

# check: p rows per cohort×wave
stopifnot(all((rq1_table_B %>% dplyr::count(country, timepoint) %>% dplyr::pull(n)) == length(nodes)))

```

```{r}
#| label: rq1-inline-report-helpers
#| include: false

node_label_map <- c(
  "Inhibition"            = "ef_inhibition",
  "Cognitive flexibility" = "ef_cogflex",
  "Working memory"        = "ef_workingmem"
)

normalise_country <- function(x) {
  dplyr::case_when(
    x %in% c("Australia", "AU")    ~ "AU",
    x %in% c("South Africa", "SA") ~ "SA",
    TRUE ~ x
  )
}

canonical_edge_key <- function(edge_label) {
  # accept en dash or hyphen
  parts <- trimws(strsplit(edge_label, "–|-", perl = TRUE)[[1]])
  stopifnot(length(parts) == 2)

  vars <- unname(node_label_map[parts])
  if (any(is.na(vars))) {
    stop("Unknown node label in: ", edge_label,
         "\nExpected one of: ", paste(names(node_label_map), collapse = ", "))
  }

  paste(sort(vars), collapse = " - ")
}

edge_row <- function(country, tp, edge_label) {
  ctry <- normalise_country(country)
  key  <- canonical_edge_key(edge_label)

  out <- rq1_table_A %>%
    dplyr::filter(.data$country == ctry,
                  .data$timepoint == tp,
                  .data$edge == key)

  if (nrow(out) != 1) {
    stop("Could not uniquely match: ", country, ", ", tp, ", ", edge_label,
         "\nRows matched: ", nrow(out))
  }
  out
}

edge_report <- function(country, tp, edge_label) {
  edge_row(country, tp, edge_label)$estimate
}

edge_meaningful <- function(country, tp, edge_label) {
  r <- edge_row(country, tp, edge_label)
  paste0("P(|r|>0.1)=", r$rope_p)
}

global_strength_report <- function(country, tp) {
  ctry <- normalise_country(country)
  out <- rq1_table_A %>%
    dplyr::filter(.data$country == ctry,
                  .data$timepoint == tp,
                  .data$edge == "Global strength")

  if (nrow(out) != 1) stop("Could not uniquely match global strength: ", country, ", ", tp)
  out$estimate
}

# EI reporting helpers
ei_row <- function(country, tp, node_label) {
  ctry <- normalise_country(country)

  # same label set as elsewhere
  node_key <- unname(node_label_map[node_label])
  if (is.na(node_key)) {
    stop("Unknown node label: ", node_label,
         "\nExpected one of: ", paste(names(node_label_map), collapse = ", "))
  }

  out <- rq1_table_B %>%
    dplyr::filter(.data$country == ctry,
                  .data$timepoint == tp,
                  .data$node == node_key)

  if (nrow(out) != 1) {
    stop("Could not uniquely match expected influence: ", country, ", ", tp, ", ", node_label,
         "\nRows matched: ", nrow(out))
  }
  out
}

ei_report <- function(country, tp, node_label) {
  ei_row(country, tp, node_label)$estimate
}
```

### Edges
Within-wave age-adjusted partial correlations are summarized in @tbl-rq1-gt-all and visualized in @fig-rq1-edge-forest.
In Australia, edges involving working memory showed the clearest evidence of coupling across waves. The inhibition–working memory edge was consistently positive (T1: `r edge_report("Australia", "T1", "Inhibition – Working memory")`; T2: `r edge_report("Australia", "T2", "Inhibition – Working memory")`; T3: `r edge_report("Australia", "T3", "Inhibition – Working memory")`) and reliably exceeded the meaningfulness threshold (T1: `r edge_meaningful("Australia", "T1", "Inhibition – Working memory")`; T2: `r edge_meaningful("Australia", "T2", "Inhibition – Working memory")`; T3: `r edge_meaningful("Australia", "T3", "Inhibition – Working memory")`). The cognitive flexibility–working memory edge was also positive across waves (T1: `r edge_report("Australia", "T1", "Cognitive flexibility – Working memory")`; T2: `r edge_report("Australia", "T2", "Cognitive flexibility – Working memory")`; T3: `r edge_report("Australia", "T3", "Cognitive flexibility – Working memory")`) and exceeded the meaningfulness threshold (meaningfulness: T1: `r edge_meaningful("Australia", "T1", "Cognitive flexibility – Working memory")`; T2: `r edge_meaningful("Australia", "T2", "Cognitive flexibility – Working memory")`; T3: `r edge_meaningful("Australia", "T3", "Cognitive flexibility – Working memory")`). In contrast, the cognitive flexibility–inhibition edge was weaker and more wave-dependent (T1: `r edge_report("Australia", "T1", "Cognitive flexibility – Inhibition")`; T2: `r edge_report("Australia", "T2", "Cognitive flexibility – Inhibition")`; T3: `r edge_report("Australia", "T3", "Cognitive flexibility – Inhibition")`), with less consistent evidence that it exceeded the meaningfulness threshold (T1: `r edge_meaningful("Australia", "T1", "Cognitive flexibility – Inhibition")`; T2: `r edge_meaningful("Australia", "T2", "Cognitive flexibility – Inhibition")`; T3: `r edge_meaningful("Australia", "T3", "Cognitive flexibility – Inhibition")`).

In South Africa, the inhibition–working memory edge remained positive across waves (T1: `r edge_report("South Africa", "T1", "Inhibition – Working memory")`; T2: `r edge_report("South Africa", "T2", "Inhibition – Working memory")`) and met the meaningfulness criterion more consistently than the other edges (T1: `r edge_meaningful("South Africa", "T1", "Inhibition – Working memory")`; T2: `r edge_meaningful("South Africa", "T2", "Inhibition – Working memory")`). The cognitive flexibility–inhibition edge was stronger at T1 (`r edge_report("South Africa", "T1", "Cognitive flexibility – Inhibition")`) but attenuated at T2 (`r edge_report("South Africa", "T2", "Cognitive flexibility – Inhibition")`) and did not reliably exceed the meaningfulness threshold at T2 (T1: `r edge_meaningful("South Africa", "T1", "Cognitive flexibility – Inhibition")`; T2: `r edge_meaningful("South Africa", "T2", "Cognitive flexibility – Inhibition")`). In contrast to the Australian results, he cognitive flexibility–working memory edge was comparatively weaker and uncertain across waves (T1: `r edge_report("South Africa", "T1", "Cognitive flexibility – Working memory")`; T2: `r edge_report("South Africa", "T2", "Cognitive flexibility – Working memory")`).

\clearpage

```{r}
#| label: tbl-rq1-gt-all 
#| tbl-cap: "Age-adjusted EF network summaries by cohort×wave. Panels show edges, global strength, and expected influence (posterior median [95% CrI]). For edges, cells also show $P(|r| > r\\text{ rope})$." 
#| include: true 

# labels for EI rows
node_to_label <- setNames(names(node_label_map), node_label_map)

# Build combined RQ1 table (Edges + Global strength + Expected influence)
rq1_table_all <- dplyr::bind_rows(
  # Edges panel
  rq1_edges %>%
    dplyr::transmute(
      panel       = "Edges",
      country, timepoint, n, pct_missing,
      term        = edge,
      estimate,
      rope_p
    ),

  # Global strength panel
  rq1_gs %>%
    dplyr::transmute(
      panel       = "Global strength",
      country, timepoint, n, pct_missing,
      term        = edge,     # "Global strength"
      estimate,
      rope_p      = ""        # blank
    ),

  # Expected influence panel
  rq1_table_B %>%
    dplyr::transmute(
      panel       = "Expected influence",
      country, timepoint, n, pct_missing,
      term        = unname(node_to_label[node]),  # ef_* -> readable label
      estimate,
      rope_p      = ""                            # blank
    )
) %>%
  dplyr::mutate(
    panel       = factor(panel, levels = c("Edges", "Global strength", "Expected influence")),
    pct_missing = round(pct_missing, 1),
    n           = as.integer(n)
  ) %>%
  dplyr::arrange(panel, country, timepoint, term)

# GT table (same formatting/padding as before)
gt_rq1_all <- rq1_table_all %>%
  gt::gt(
    rowname_col   = "term",
    groupname_col = "panel"
  ) %>%
  # add LaTeX vertical space between caption and header in PDF
  gt::tab_header(title = gt::md("\\vspace{10pt}")) %>%
  gt::tab_stubhead(label = "Measure") %>%
  gt::cols_label(
    country     = "Cohort",
    timepoint   = "Wave",
    estimate    = "Median [95% CrI]",
    rope_p      = paste0("P(|r|>", rope, ")"),
    n           = "N",
    pct_missing = "% missing cells"
  ) %>%
  gt::cols_align(
    align   = "center",
    columns = c(country, timepoint, estimate, rope_p, n, pct_missing)
  ) %>%
  gt::sub_missing(columns = "rope_p", missing_text = "") %>%
  gt::tab_options(
    table.font.size        = gt::px(11),
    row_group.font.weight  = "bold",
    heading.title.font.size = gt::px(1)  # minimise spacer row height
  )

gt_rq1_all

```

```{r}
#| label: fig-rq1-edge-forest
#| fig-cap: |
#|   **Within-wave EF coupling (posterior partial correlations).** Points show posterior medians; bars show 95% credible intervals. Solid line = 0; dashed lines = ROPE (±0.10).
#| include: true

rope <- 0.10

edges_df2 <- edge_tbl %>%
  dplyr::mutate(
    timepoint = factor(timepoint, levels = c("T1","T2","T3")),
    country   = factor(country, levels = c("AU","SA")),

    # canonical edge key from node columns (order-invariant, delimiter-stable)
    edge_key = paste(pmin(node1, node2), pmax(node1, node2), sep = " — ")
  ) %>%
  # keep only the 3 EF edges
  dplyr::filter(edge_key %in% c(
    "ef_cogflex — ef_inhibition",
    "ef_cogflex — ef_workingmem",
    "ef_inhibition — ef_workingmem"
  )) %>%
  dplyr::mutate(
    edge_short = dplyr::recode(
      edge_key,
      "ef_cogflex — ef_inhibition"    = "CogFlex–Inhib",
      "ef_cogflex — ef_workingmem"    = "CogFlex–WM",
      "ef_inhibition — ef_workingmem" = "Inhib–WM"
    ),
    edge_short = factor(edge_short, levels = c("Inhib–WM","CogFlex–WM","CogFlex–Inhib"))
  )

stopifnot(nrow(edges_df2) > 0)
stopifnot(all(c("q025","q50","q975") %in% names(edges_df2)))
stopifnot(!anyNA(edges_df2$edge_short))

ggplot(edges_df2, aes(x = q50, y = edge_short, colour = edge_short)) +
  geom_rect(
    data = tibble::tibble(xmin = -rope, xmax = rope, ymin = -Inf, ymax = Inf),
    aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
    inherit.aes = FALSE,
    fill = "grey50",
    alpha = 0.08
  ) +
  geom_vline(xintercept = 0, linewidth = 0.6) +
  geom_vline(xintercept = c(-rope, rope), linetype = "dashed", linewidth = 0.5) +
  geom_errorbarh(aes(xmin = q025, xmax = q975), height = 0, linewidth = 0.7) +
  geom_point(size = 2.4) +
  facet_grid(timepoint ~ country, switch = "y") +
  guides(colour = "none") +
  labs(
    #title = "Within-wave EF coupling",  # <- plot title (optional)
    x = "Partial correlation (posterior median, 95% CrI)",
    y = NULL
  ) +
  theme_bw(base_size = 12) +
  theme(
    panel.grid.major.y = element_blank(),
    panel.grid.minor   = element_blank(),
    strip.placement    = "outside",
    strip.background   = element_blank(),
    strip.text.y.right = element_text(angle = 0)
  )
```
\clearpage

### Global strength
Global strength estimates (sum of absolute partial correlations over unique edges) are reported in @tbl-rq1-gt-all and visualized over time in @fig-rq1-global-strength-trend. Australia showed stable global strength across waves (T1: `r global_strength_report("Australia", "T1")`; T2: `r global_strength_report("Australia", "T2")`; T3: `r global_strength_report("Australia", "T3")`), whereas South Africa showed lower global strength and attenuation from T1 to T2 (T1: `r global_strength_report("South Africa", "T1")`;
T2: `r global_strength_report("South Africa", "T2")`).

```{r}
#| label: fig-rq1-global-strength-trend
#| fig-cap: "Global strength over time by cohort. Points show posterior median; whiskers show 95% credible intervals. Global strength is the sum of absolute partial correlations over unique edges."
#| fig-width: 6.2
#| fig-height: 4

library(dplyr)
library(ggplot2)

gs_df <- gs_tbl %>%
  mutate(
    country   = factor(country, levels = c("AU", "SA")),
    timepoint = factor(timepoint, levels = c("T1","T2","T3"))
  )

ggplot(gs_df, aes(x = timepoint, y = q50, group = country)) +
  geom_line(linewidth = 0.7) +
  geom_errorbar(aes(ymin = q025, ymax = q975), width = 0.08, linewidth = 0.7) +
  geom_point(size = 2.0) +
  facet_grid(. ~ country) +
  labs(
    x = "Wave",
    y = "Global strength (posterior median, 95% CrI)"
  ) +
  theme_bw(base_size = 11) +
  theme(
    panel.grid.minor = element_blank(),
    strip.background = element_blank()
  )
```
\clearpage

### Centrality (Expected influence)
Expected influence estimates (signed sum of incident partial correlations) are summarized in @tbl-rq1-gt-all and visualized over time by node in @fig-rq1-ei-trend-by-node-n. In Australia, expected influence was consistently positive across nodes and waves, with working memory showing the highest expected influence across waves (T1: `r ei_report("Australia", "T1", "Working memory")`; T2: `r ei_report("Australia", "T2", "Working memory")`; T3: `r ei_report("Australia", "T3", "Working memory")`). Inhibition showed comparatively high expected influence from T2 onward (T1: `r ei_report("Australia", "T1", "Inhibition")`; T2: `r ei_report("Australia", "T2", "Inhibition")`; T3: `r ei_report("Australia", "T3", "Inhibition")`), whereas cognitive flexibility was lower and more stable across waves (T1: `r ei_report("Australia", "T1", "Cognitive flexibility")`; T2: `r ei_report("Australia", "T2", "Cognitive flexibility")`; T3: `r ei_report("Australia", "T3", "Cognitive flexibility")`). These patterns are evident in @fig-rq1-ei-trend-by-node-n, which shows sustained positive centrality for all three nodes in the Australian cohort, with working memory and inhibition contributing most strongly to within-wave coupling across time.

In South Africa, expected influence was positive but generally lower, with attenuation from T1 to T2 for inhibition and cognitive flexibility (inhibition: T1: `r ei_report("South Africa", "T1", "Inhibition")`; T2: `r ei_report("South Africa", "T2", "Inhibition")`; cognitive flexibility: T1: `r ei_report("South Africa", "T1", "Cognitive flexibility")`; T2: `r ei_report("South Africa", "T2", "Cognitive flexibility")`). Working memory showed comparatively stable expected influence across waves (T1: `r ei_report("South Africa", "T1", "Working memory")`; T2: `r ei_report("South Africa", "T2", "Working memory")`). @fig-rq1-ei-trend-by-node-n shows a downward shift from T1 to T2 for inhibition and cognitive flexibility in South Africa, while working memory remains comparatively steady.
\clearpage

```{r}
#| label: fig-rq1-ei-trend-by-node-n
#| fig-cap: "Expected influence over time by cohort and node. Points show posterior median; whiskers show 95% credible intervals. N per wave is shown beneath the zero line within each panel."
#| fig-width: 7.8
#| fig-height: 6

library(dplyr)
library(tidyr)
library(ggplot2)
library(purrr)

stopifnot(exists("fit_tbl"), exists("nodes"), exists("ei_summaries"))

fit_tbl_uniq <- fit_tbl %>%
  filter(!purrr::map_lgl(fit, is.null)) %>%
  arrange(country, timepoint) %>%
  group_by(country, timepoint) %>%
  slice(1) %>%
  ungroup()

rq1_ei <- fit_tbl_uniq %>%
  transmute(country, timepoint, n, fit) %>%
  mutate(ei = purrr::map(fit, ~ ei_summaries(.x, node_names = nodes))) %>%
  unnest(ei) %>%
  mutate(
    country   = factor(country, levels = c("AU","SA")),
    timepoint = factor(timepoint, levels = c("T1","T2","T3")),
    node      = factor(node, levels = nodes)
  )

node_labels <- c(
  ef_inhibition = "Inhibition",
  ef_cogflex    = "Cognitive flexibility",
  ef_workingmem = "Working memory"
)

# N labels replicated into each node panel
n_lab <- fit_tbl_uniq %>%
  transmute(
    country   = factor(country, levels = c("AU","SA")),
    timepoint = factor(timepoint, levels = c("T1","T2","T3")),
    n
  ) %>%
  tidyr::crossing(node = factor(nodes, levels = nodes)) %>%
  mutate(label = paste0("n=", n))

# Choose a stable y-position *below* 0 for each (country × node) panel:
# - if 0 is within the panel range, put N slightly below 0
# - otherwise put it slightly above the panel minimum
panel_y <- rq1_ei %>%
  group_by(country, node) %>%
  summarise(
    y_min = min(q025, na.rm = TRUE),
    y_max = max(q975, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    span = y_max - y_min,
    y_n  = if_else(
      (y_min <= 0) & (0 <= y_max),
      0 - 0.08 * span,
      y_min + 0.06 * span
    )
  )

n_lab2 <- n_lab %>%
  left_join(panel_y, by = c("country","node"))

ggplot(rq1_ei, aes(x = timepoint, y = q50, group = 1)) +
  geom_hline(yintercept = 0, linewidth = 0.7) +
  geom_line(linewidth = 0.9) +
  geom_errorbar(aes(ymin = q025, ymax = q975), width = 0.10, linewidth = 0.9) +
  geom_point(size = 2.7) +

  # N labels: boxed, below the 0-line, not competing with points
  geom_label(
    data = n_lab2,
    aes(x = timepoint, y = y_n, label = label),
    inherit.aes = FALSE,
    size = 3.1,
    label.size = 0,        # no border
    label.padding = unit(0.12, "lines"),
    fill = "white",
    colour = "black",
    alpha = 0.9
  ) +

  facet_grid(
    node ~ country,
    labeller = labeller(node = node_labels),
    switch = "y"
  ) +
  labs(
    x = "Wave",
    y = "Expected influence (posterior median, 95% CrI)"
  ) +
  theme_bw(base_size = 12) +
  theme(
    panel.grid.minor = element_blank(),
    strip.placement  = "outside",

    # put node strips on the LEFT
    strip.text.y.left  = element_text(angle = 90),
    strip.text.y.right = element_blank(),
    strip.background.y = element_blank()
  ) +
  coord_cartesian(clip = "off") +
  scale_y_continuous(expand = expansion(mult = c(0.12, 0.05)))
```

```{r}
#| label: rq2-difference-helpers
#| include: false

rope_delta <- 0.10

summ_draws_delta <- function(draws, rope = rope_delta) {
  qs <- stats::quantile(draws, c(.025, .5, .975), na.rm = TRUE)
  tibble::tibble(
    q025 = unname(qs[1]),
    q50  = unname(qs[2]),
    q975 = unname(qs[3]),
    p_outside_rope = mean(abs(draws) > rope, na.rm = TRUE)
  )
}

# Get a fit object for a specific country×timepoint
get_fit <- function(country, tp, fit_tbl_uniq) {
  out <- fit_tbl_uniq %>%
    dplyr::filter(country == !!country, timepoint == !!tp) %>%
    dplyr::pull(fit)
  if (length(out) != 1) stop("Could not uniquely match fit: ", country, " ", tp)
  out[[1]]
}

# Posterior draws of Δ edges (fit_B - fit_A), returned as a named list
edge_delta_draws <- function(fit_A, fit_B, node_names = nodes) {
  A <- fit_A$post_samp$pcors
  B <- fit_B$post_samp$pcors

  # enforce names
  dimnames(A) <- list(node_names, node_names, NULL)
  dimnames(B) <- list(node_names, node_names, NULL)

  # align draws
  S <- min(dim(A)[3], dim(B)[3])
  A <- A[, , (dim(A)[3] - S + 1):dim(A)[3], drop = FALSE]
  B <- B[, , (dim(B)[3] - S + 1):dim(B)[3], drop = FALSE]

  D <- B - A  # Δ = later - earlier

  p <- dim(D)[1]
  idx <- which(upper.tri(matrix(FALSE, p, p)), arr.ind = TRUE)

  out <- vector("list", nrow(idx))
  nms <- character(nrow(idx))

  for (i in seq_len(nrow(idx))) {
    a <- idx[i, 1]; b <- idx[i, 2]
    out[[i]] <- D[a, b, ]
    nms[i] <- paste(sort(c(node_names[a], node_names[b])), collapse = " - ")
  }
  names(out) <- nms
  out
}

# Posterior draws of Δ global strength (fit_B - fit_A)
gs_delta_draws <- function(fit_A, fit_B) {
  gsA <- global_strength_draws(fit_A)
  gsB <- global_strength_draws(fit_B)
  S <- min(length(gsA), length(gsB))
  tail(gsB, S) - tail(gsA, S)
}

# Posterior draws of Δ expected influence per node (fit_B - fit_A), S x p
ei_delta_draws <- function(fit_A, fit_B, node_names = nodes) {
  EI_A <- expected_influence_draws(fit_A, node_names = node_names) # S x p
  EI_B <- expected_influence_draws(fit_B, node_names = node_names)

  S <- min(nrow(EI_A), nrow(EI_B))
  EI_B[(nrow(EI_B) - S + 1):nrow(EI_B), , drop = FALSE] -
    EI_A[(nrow(EI_A) - S + 1):nrow(EI_A), , drop = FALSE]
}

fmt_ci_delta <- function(m, lo, hi, digits = 2) {
  sprintf(paste0("%.", digits, "f [%.", digits, "f, %.", digits, "f]"), m, lo, hi)
}
fmt_p <- function(p, digits = 2) sprintf(paste0("%.", digits, "f"), p)

```

```{r}
#| label: rq2-ei-delta-summaries
#| include: false

ei_delta_summaries <- function(fit_A, fit_B,
                               node_names = nodes,
                               probs = c(.025, .5, .975),
                               rope = NULL) {

  EI <- ei_delta_draws(fit_A, fit_B, node_names = node_names)  # S x p

  # guardrail: enforce colnames
  if (is.null(colnames(EI))) colnames(EI) <- node_names

  out <- tibble::tibble(
    node = colnames(EI),
    q025 = apply(EI, 2, stats::quantile, probs[1], na.rm = TRUE),
    q50  = apply(EI, 2, stats::quantile, probs[2], na.rm = TRUE),
    q975 = apply(EI, 2, stats::quantile, probs[3], na.rm = TRUE)
  )

  if (!is.null(rope)) {
    out <- dplyr::mutate(
      out,
      p_outside_rope = apply(abs(EI) > rope, 2, mean, na.rm = TRUE)
    )
  }

  out
}

```

```{r}
#| label: rq2-build-delta-tables
#| include: false

# Use the same unique fit table you built for RQ1
fit_tbl_uniq <- fit_tbl %>%
  dplyr::filter(!purrr::map_lgl(fit, is.null)) %>%
  dplyr::arrange(country, timepoint) %>%
  dplyr::group_by(country, timepoint) %>%
  dplyr::slice(1) %>%
  dplyr::ungroup()

# Define adjacent-wave comparisons per cohort
rq2_pairs <- tibble::tibble(
  country = c("AU","AU","SA"),
  tp1     = c("T1","T2","T1"),
  tp2     = c("T2","T3","T2")
)

# Edge deltas (Δr)
rq2_delta_edges <- rq2_pairs %>%
  dplyr::mutate(
    fit1 = purrr::pmap(list(country, tp1), ~ get_fit(..1, ..2, fit_tbl_uniq)),
    fit2 = purrr::pmap(list(country, tp2), ~ get_fit(..1, ..2, fit_tbl_uniq)),
    delta_list = purrr::map2(fit1, fit2, ~ edge_delta_draws(.x, .y, node_names = nodes))
  ) %>%
  dplyr::select(country, tp1, tp2, delta_list) %>%
  tidyr::unnest_longer(delta_list, values_to = "draws", indices_to = "edge") %>%
  dplyr::mutate(stats = purrr::map(draws, ~ summ_draws_delta(.x, rope = rope_delta))) %>%
  tidyr::unnest(stats) %>%
  dplyr::transmute(
    panel    = "Edges (Δr)",
    country,
    contrast = paste0(tp2, " \u2212 ", tp1),
    term     = edge,
    estimate = fmt_ci_delta(q50, q025, q975, digits = 2),
    rope_p   = fmt_p(p_outside_rope, digits = 2)
  )

# Global strength deltas (ΔGS)
rq2_delta_gs <- rq2_pairs %>%
  dplyr::mutate(
    fit1 = purrr::pmap(list(country, tp1), ~ get_fit(..1, ..2, fit_tbl_uniq)),
    fit2 = purrr::pmap(list(country, tp2), ~ get_fit(..1, ..2, fit_tbl_uniq)),
    draws = purrr::map2(fit1, fit2, ~ gs_delta_draws(.x, .y))
  ) %>%
  dplyr::mutate(stats = purrr::map(draws, ~ summ_draws_delta(.x, rope = rope_delta))) %>%
  tidyr::unnest(stats) %>%
  dplyr::transmute(
    panel    = "Global strength (Δ)",
    country,
    contrast = paste0(tp2, " \u2212 ", tp1),
    term     = "Global strength",
    estimate = fmt_ci_delta(q50, q025, q975, digits = 2),
    rope_p   = ""  # leave blank (ROPE less interpretable for GS unless you justify it)
  )

# Expected influence deltas (ΔEI)
rq2_delta_ei <- rq2_pairs %>%
  dplyr::mutate(
    fit1 = purrr::pmap(list(country, tp1), ~ get_fit(..1, ..2, fit_tbl_uniq)),
    fit2 = purrr::pmap(list(country, tp2), ~ get_fit(..1, ..2, fit_tbl_uniq)),
    ei   = purrr::map2(fit1, fit2, ~ ei_delta_summaries(.x, .y, node_names = nodes, rope = rope_delta))
  ) %>%
  tidyr::unnest(ei) %>%
  dplyr::transmute(
    panel    = "Expected influence (Δ)",
    country,
    contrast = paste0(tp2, " \u2212 ", tp1),
    term     = node,
    estimate = fmt_ci_delta(q50, q025, q975, digits = 2),
    rope_p   = fmt_p(p_outside_rope, digits = 2)   # <- keep if you want ROPE on ΔEI
  )

rq2_table_all <- dplyr::bind_rows(rq2_delta_gs, rq2_delta_edges, rq2_delta_ei) %>%
  dplyr::mutate(
    panel   = factor(panel, levels = c("Edges (Δr)", "Global strength (Δ)", "Expected influence (Δ)")),
    country = factor(country, levels = c("AU","SA"))
  ) %>%
  dplyr::arrange(panel, country, contrast, term)

rq2_table_all

```

```{r}
#| label: tbl-rq2-gt-all
#| tbl-cap: "RQ2: Change in EF network summaries across adjacent waves within cohort. Cells show posterior median [95% CrI] for Δ (later − earlier). For edges, cells also show $P(|\\Delta r| > 0.10)$."
#| include: true

rq2_table_print <- rq2_table_all %>%
  dplyr::mutate(
    term = dplyr::recode(term, !!!node_to_label)
  )

gt_rq2_all <- rq2_table_print %>%
  gt::gt(
    rowname_col   = "term",
    groupname_col = "panel"
  ) %>%
  gt::tab_stubhead(label = "Measure") %>%
  gt::cols_label(
    country   = "Cohort",
    contrast  = "Contrast",
    estimate  = "Median [95% CrI]",
    rope_p    = paste0("P(|Δr|>", rope_delta, ")")
  ) %>%
  gt::cols_align(
    align = "center",
    columns = c(country, contrast, estimate, rope_p)
  ) %>%
  gt::sub_missing(columns = "rope_p", missing_text = "") %>%
  gt::tab_options(
    table.font.size = gt::px(11),
    row_group.font.weight = "bold"
  )

gt_rq2_all
```

```{r}
#| label: rq2-inline-report-helpers
#| include: false

# helper to match the contrast string used in rq2_table_all
rq2_contrast <- function(tp2, tp1) paste0(tp2, " \u2212 ", tp1)

# generic lookup in rq2_table_all
rq2_cell <- function(panel, country, tp2, tp1, term, col = c("estimate","rope_p")) {
  col <- match.arg(col)
  x <- rq2_table_all %>%
    dplyr::filter(
      panel == !!panel,
      country == !!country,
      contrast == rq2_contrast(tp2, tp1),
      term == !!term
    ) %>%
    dplyr::pull(!!rlang::sym(col))
  if (length(x) != 1) stop("No unique match for: ", panel, " / ", country, " / ", rq2_contrast(tp2, tp1), " / ", term)
  x[[1]]
}

# convenience wrappers
rq2_edge_report      <- function(country, tp2, tp1, edge) rq2_cell("Edges (Δr)", country, tp2, tp1, edge, "estimate")
rq2_edge_meaningful  <- function(country, tp2, tp1, edge) rq2_cell("Edges (Δr)", country, tp2, tp1, edge, "rope_p")

rq2_gs_report        <- function(country, tp2, tp1)       rq2_cell("Global strength (Δ)", country, tp2, tp1, "Global strength", "estimate")

rq2_ei_report        <- function(country, tp2, tp1, node) rq2_cell("Expected influence (Δ)", country, tp2, tp1, node, "estimate")
rq2_ei_meaningful    <- function(country, tp2, tp1, node) rq2_cell("Expected influence (Δ)", country, tp2, tp1, node, "rope_p")

```
\clearpage

Across adjacent waves within cohort, posterior median changes in EF network summaries were generally small and imprecise (Table @tbl-rq2-gt-all), with 95% credible intervals that consistently overlapped zero.

In Australia, edge changes from T1 to T2 were modest (ef_cogflex - ef_inhibition: `r rq2_edge_report("AU", "T2", "T1", "ef_cogflex - ef_inhibition")`; ef_cogflex - ef_workingmem: `r rq2_edge_report("AU", "T2", "T1", "ef_cogflex - ef_workingmem")`; ef_inhibition - ef_workingmem: `r rq2_edge_report("AU", "T2", "T1", "ef_inhibition - ef_workingmem")`) and posterior support for meaningful edge change was limited (P(|Δr| > 0.10): ef_cogflex - ef_inhibition: `r rq2_edge_meaningful("AU", "T2", "T1", "ef_cogflex - ef_inhibition")`; ef_cogflex - ef_workingmem: `r rq2_edge_meaningful("AU", "T2", "T1", "ef_cogflex - ef_workingmem")`; ef_inhibition - ef_workingmem: `r rq2_edge_meaningful("AU", "T2", "T1", "ef_inhibition - ef_workingmem")`). From T2 to T3, changes were similarly small (ef_cogflex - ef_inhibition: `r rq2_edge_report("AU", "T3", "T2", "ef_cogflex - ef_inhibition")`; ef_cogflex - ef_workingmem: `r rq2_edge_report("AU", "T3", "T2", "ef_cogflex - ef_workingmem")`; ef_inhibition - ef_workingmem: `r rq2_edge_report("AU", "T3", "T2", "ef_inhibition - ef_workingmem")`) with limited posterior support for meaningful change (P(|Δr| > 0.10): ef_cogflex - ef_inhibition: `r rq2_edge_meaningful("AU", "T3", "T2", "ef_cogflex - ef_inhibition")`; ef_cogflex - ef_workingmem: `r rq2_edge_meaningful("AU", "T3", "T2", "ef_cogflex - ef_workingmem")`; ef_inhibition - ef_workingmem: `r rq2_edge_meaningful("AU", "T3", "T2", "ef_inhibition - ef_workingmem")`). Global strength was also stable in Australia (T2 − T1: `r rq2_gs_report("AU", "T2", "T1")`; T3 − T2: `r rq2_gs_report("AU", "T3", "T2")`). Expected influence showed small shifts, with the strongest suggestion being an increase for inhibition from T1 to T2 (Cognitive flexibility: `r rq2_ei_report("AU", "T2", "T1", "ef_cogflex")`; Inhibition: `r rq2_ei_report("AU", "T2", "T1", "ef_inhibition")`; Working memory: `r rq2_ei_report("AU", "T2", "T1", "ef_workingmem")`), and corresponding posterior support for a meaningful ΔEI (P(|Δ| > 0.10)) was highest for inhibition (Cognitive flexibility: `r rq2_ei_meaningful("AU", "T2", "T1", "ef_cogflex")`; Inhibition: `r rq2_ei_meaningful("AU", "T2", "T1", "ef_inhibition")`; Working memory: `r rq2_ei_meaningful("AU", "T2", "T1", "ef_workingmem")`). From T2 to T3, expected influence changes were again modest (Cognitive flexibility: `r rq2_ei_report("AU", "T3", "T2", "ef_cogflex")`; Inhibition: `r rq2_ei_report("AU", "T3", "T2", "ef_inhibition")`; Working memory: `r rq2_ei_report("AU", "T3", "T2", "ef_workingmem")`) with only moderate posterior support for meaningful shifts (Cognitive flexibility: `r rq2_ei_meaningful("AU", "T3", "T2", "ef_cogflex")`; Inhibition: `r rq2_ei_meaningful("AU", "T3", "T2", "ef_inhibition")`; Working memory: `r rq2_ei_meaningful("AU", "T3", "T2", "ef_workingmem")`).

In South Africa, edge changes from T1 to T2 were small overall (ef_cogflex - ef_inhibition: `r rq2_edge_report("SA", "T2", "T1", "ef_cogflex - ef_inhibition")`; ef_cogflex - ef_workingmem: `r rq2_edge_report("SA", "T2", "T1", "ef_cogflex - ef_workingmem")`; ef_inhibition - ef_workingmem: `r rq2_edge_report("SA", "T2", "T1", "ef_inhibition - ef_workingmem")`), with the largest nominal decrease observed for ef_cogflex - ef_inhibition and only moderate posterior support for a meaningful change (P(|Δr| > 0.10): ef_cogflex - ef_inhibition: `r rq2_edge_meaningful("SA", "T2", "T1", "ef_cogflex - ef_inhibition")`; ef_cogflex - ef_workingmem: `r rq2_edge_meaningful("SA", "T2", "T1", "ef_cogflex - ef_workingmem")`; ef_inhibition - ef_workingmem: `r rq2_edge_meaningful("SA", "T2", "T1", "ef_inhibition - ef_workingmem")`). Global strength did not show a reliable shift in South Africa (T2 − T1: `r rq2_gs_report("SA", "T2", "T1")`). Expected influence changes were modest, with attenuation for cognitive flexibility and inhibition and comparatively stable working memory (Cognitive flexibility: `r rq2_ei_report("SA", "T2", "T1", "ef_cogflex")`; Inhibition: `r rq2_ei_report("SA", "T2", "T1", "ef_inhibition")`; Working memory: `r rq2_ei_report("SA", "T2", "T1", "ef_workingmem")`), and posterior support for meaningful ΔEI was moderate for cognitive flexibility and inhibition (Cognitive flexibility: `r rq2_ei_meaningful("SA", "T2", "T1", "ef_cogflex")`; Inhibition: `r rq2_ei_meaningful("SA", "T2", "T1", "ef_inhibition")`; Working memory: `r rq2_ei_meaningful("SA", "T2", "T1", "ef_workingmem")`).

```{r}


```

\newpage

# References

::: {#refs}
:::

```{r}
#| label: demographics-table-setup
#| include: false

# labels + formatting helpers
ef_labels <- c(
  ef_inhibition = "Inhibition",
  ef_cogflex    = "Cognitive flexibility",
  ef_workingmem = "Working memory"
)

fmt_mean_sd <- function(mean, sd, digits = 2) {
  ifelse(
    is.na(mean) | is.na(sd),
    NA_character_,
    sprintf(paste0("%.", digits, "f (%.", digits, "f)"), mean, sd)
  )
}

fmt_med_rng <- function(median, min, max, digits = 2) {
  ifelse(
    is.na(median) | is.na(min) | is.na(max),
    NA_character_,
    sprintf(paste0("%.", digits, "f [%.", digits, "f, %.", digits, "f]"),
            median, min, max)
  )
}

# standardise country labels for tables
country_for_table <- function(x) {
  dplyr::case_when(
    x == "AU" ~ "Australia",
    x == "SA" ~ "SA",
    TRUE ~ as.character(x)
  )
}

# build tp_* inputs used in Table 1
stopifnot(exists("ef_all_keep"), exists("age_all_keep"))
stopifnot(all(c("country","timepoint","id","variable","value") %in% names(ef_all_keep)))
stopifnot(all(c("country","timepoint","id","age") %in% names(age_all_keep)))

tp_ef_desc <- ef_all_keep %>%
  filter(!is.na(timepoint)) %>%
  mutate(
    country   = country_for_table(country),
    timepoint = as.character(timepoint),
    variable  = as.character(variable)
  ) %>%
  group_by(country, timepoint, variable) %>%
  summarise(
    n    = sum(!is.na(value)),
    mean = ifelse(all(is.na(value)), NA_real_, mean(value, na.rm = TRUE)),
    sd   = ifelse(sum(!is.na(value)) > 1, sd(value, na.rm = TRUE), NA_real_),
    .groups = "drop"
  )

tp_age <- age_all_keep %>%
  filter(!is.na(timepoint)) %>%
  mutate(
    country   = country_for_table(country),
    timepoint = as.character(timepoint)
  ) %>%
  group_by(country, timepoint) %>%
  summarise(
    age_n      = sum(!is.na(age)),
    age_mean   = ifelse(age_n > 0, mean(age, na.rm = TRUE), NA_real_),
    age_sd     = ifelse(age_n > 1, sd(age, na.rm = TRUE), NA_real_),
    age_median = ifelse(age_n > 0, median(age, na.rm = TRUE), NA_real_),
    age_min    = ifelse(age_n > 0, min(age, na.rm = TRUE), NA_real_),
    age_max    = ifelse(age_n > 0, max(age, na.rm = TRUE), NA_real_),
    .groups = "drop"
  )

if (!exists("sa_sex_long") || !exists("aus_sex_tp")) {
  stop("Need sa_sex_long and aus_sex_tp (or rebuild your sex objects earlier).")
}

tp_sex <- bind_rows(
  sa_sex_long %>% select(country, timepoint, id, sex),
  aus_sex_tp  %>% select(country, timepoint, id, sex)
) %>%
  mutate(
    country   = country_for_table(country),
    timepoint = as.character(timepoint),
    sex       = as.character(sex)
  ) %>%
  count(country, timepoint, sex, name = "n") %>%
  group_by(country, timepoint) %>%
  mutate(pct = 100 * n / sum(n)) %>%
  ungroup() %>%
  transmute(
    country,
    timepoint,
    level = sex,
    cell  = paste0(n, " (", sprintf("%.1f", pct), "%)")
  )

stopifnot(nrow(tp_ef_desc) > 0, nrow(tp_age) > 0, nrow(tp_sex) > 0)

add_group <- function(df) {
  df %>%
    mutate(
      country   = country_for_table(country),
      timepoint = as.character(timepoint),
      group     = paste(country, timepoint, sep = " — ")
    )
}

make_group_levels <- function(...) {
  bind_rows(...) %>%
    distinct(country, timepoint) %>%
    mutate(
      country   = country_for_table(country),
      timepoint = factor(as.character(timepoint), levels = paste0("T", 1:10)),
      group     = paste(country, timepoint, sep = " — ")
    ) %>%
    arrange(match(country, c("Australia","SA")), timepoint) %>%
    pull(group)
}

cont_block_long <- function(tp_df, section_title) {
  add_group(tp_df) %>%
    transmute(
      section = section_title,
      variable,
      group,
      n   = as.character(n),
      msd = fmt_mean_sd(mean, sd, digits = 2)
    ) %>%
    pivot_longer(cols = c(n, msd), names_to = "stat", values_to = "value") %>%
    mutate(
      row = case_when(
        stat == "n"   ~ paste0(variable, ", n"),
        stat == "msd" ~ paste0(variable, ", Mean (SD)")
      )
    ) %>%
    select(section, row, group, value)
}

to_wide <- function(long_df, group_levels) {
  long_df %>%
    mutate(group = factor(group, levels = group_levels)) %>%
    select(section, row, group, value) %>%
    pivot_wider(names_from = group, values_from = value) %>%
    arrange(section, row)
}

```

# Demographics {.appendix #render-table1}
::: {.landscape}
```{r}
#| label: render-table1
#| tbl-cap: "Age and executive function by country and timepoint. All summaries are anchored to children with any EF observed at that timepoint (partial EF allowed)."
#| include: true
#| ft.arraystretch: 1

group_levels <- make_group_levels(
  tp_age %>% distinct(country, timepoint),
  tp_ef_desc %>% distinct(country, timepoint),
  tp_sex %>% distinct(country, timepoint)
)

# EF block: do n and mean(sd) in one pass
ef_long <- add_group(tp_ef_desc) %>%
  mutate(domain = unname(ef_labels[as.character(variable)])) %>%
  transmute(
    section = "Executive function",
    domain,
    group,
    n   = as.character(n),
    msd = fmt_mean_sd(mean, sd, digits = 2)
  ) %>%
  pivot_longer(cols = c(n, msd), names_to = "stat", values_to = "value") %>%
  mutate(row = case_when(
    stat == "n"   ~ paste0(domain, ", n"),
    stat == "msd" ~ paste0(domain, ", Mean (SD)")
  )) %>%
  select(section, row, group, value)

# Age block
age_long <- add_group(tp_age) %>%
  transmute(
    section = "Age",
    group,
    row_mean = "Age (years), Mean (SD)",
    val_mean = fmt_mean_sd(age_mean, age_sd, digits = 2),
    row_med  = "Age (years), Median [min, max]",
    val_med  = fmt_med_rng(age_median, age_min, age_max, digits = 2)
  ) %>%
  pivot_longer(
    cols = c(val_mean, val_med),
    names_to = "which",
    values_to = "value"
  ) %>%
  mutate(row = ifelse(which == "val_mean", row_mean, row_med)) %>%
  select(section, row, group, value)

# Sex block
sex_long <- add_group(tp_sex) %>%
  transmute(
    section = "Sex",
    row = paste0(level, ", n (%)"),
    group,
    value = cell
  )

metrics1_long <- bind_rows(ef_long, age_long, sex_long) %>%
  mutate(section = factor(section, levels = c("Executive function", "Age", "Sex")))

paper_table1 <- to_wide(metrics1_long, group_levels)

gt1 <- paper_table1 %>%
  gt(groupname_col = "section", rowname_col = "row") %>%
  cols_align(align = "center") %>%
  tab_options(
    table.width = pct(100),
    row_group.as_column = TRUE,
    table.font.size = px(11)
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_row_groups()
  )

gt1
```
:::

```{r}
#| label: summarise-table2-components
#| include: false

sa_edu_tp     <- desc_cat_tp(sa_ses,     "edu_sa",     sa_any_ids,  "Caregiver education (SA)")
aus_edu_tp    <- desc_cat_tp(aus_ses_tp, "edu_aus",    aus_any_ids, "Caregiver education (AUS)")
aus_income_tp <- desc_cat_tp(aus_ses_tp, "income_aus", aus_any_ids, "Household income (AUS)")

ses_tp_long2 <- bind_rows(sa_edu_tp, aus_edu_tp, aus_income_tp) %>%
  mutate(country = country_for_table(country)) %>%
  arrange(country, timepoint, variable, level)

tp_income_sa <- summ_cont_tp(sa_ses, "nids_assets_sa", sa_any_ids, "Household income (SA)") %>%
  mutate(country = country_for_table(country))

tp_hle_sa <- bind_rows(
  summ_cont_tp(sa_ses, "hla_frequency1",       sa_any_ids, "HLE activity frequency (sum)"),
  summ_cont_tp(sa_ses, "num_caregivers_clean", sa_any_ids, "HLE: unique caregiver types involved"),
  summ_cont_tp(sa_ses, "books_toys_total1",    sa_any_ids, "HLE: books/toys total"),
  summ_cont_tp(sa_ses, "time_total1",          sa_any_ids, "HLE: time total")
) %>%
  mutate(country = country_for_table(country)) %>%
  arrange(country, timepoint, variable)

tp_hle_aus <- summ_cont_tp(
  aus_ses_tp, "hle_aus", aus_any_ids,
  "Home learning environment (AUS; HLE Index)"
) %>%
  mutate(country = country_for_table(country))
```

::: {.landscape}
```{r}
#| label: render-table2
#| tbl-cap: "Socioeconomic status and home learning environment by country and timepoint."
#| include: true

group_levels <- bind_rows(
  ses_tp_long2 %>% distinct(country, timepoint),
  tp_income_sa %>% distinct(country, timepoint),
  tp_hle_sa %>% distinct(country, timepoint),
  tp_hle_aus %>% distinct(country, timepoint)
) %>%
  distinct(country, timepoint) %>%
  mutate(
    timepoint = factor(timepoint, levels = paste0("T", 1:10)),
    group = paste(country, timepoint, sep = " — ")
  ) %>%
  arrange(match(country, c("Australia","SA")), timepoint) %>%  # <-- Australia first
  pull(group)

# SA income (continuous)
income2_long <- bind_rows(
  tp_income_sa %>%
    mutate(group = paste(country, timepoint, sep = " — ")) %>%
    transmute(section = "Household income (SA)",
              row = paste0(variable, ", n"),
              group, value = as.character(n)),
  tp_income_sa %>%
    mutate(group = paste(country, timepoint, sep = " — ")) %>%
    transmute(section = "Household income (SA)",
              row = paste0(variable, ", Mean (SD)"),
              group, value = fmt_mean_sd(mean, sd, digits = 2))
)

income2_wide <- income2_long %>%
  mutate(group = factor(group, levels = group_levels)) %>%
  select(section, row, group, value) %>%
  tidyr::pivot_wider(names_from = group, values_from = value) %>%
  arrange(section, row)

# SA HLE (continuous)
hle_sa_long <- bind_rows(
  tp_hle_sa %>%
    mutate(group = paste(country, timepoint, sep = " — ")) %>%
    transmute(section = "Home learning environment (SA)",
              row = paste0(variable, ", n"),
              group, value = as.character(n)),
  tp_hle_sa %>%
    mutate(group = paste(country, timepoint, sep = " — ")) %>%
    transmute(section = "Home learning environment (SA)",
              row = paste0(variable, ", Mean (SD)"),
              group, value = fmt_mean_sd(mean, sd, digits = 2))
)

hle_sa_wide <- hle_sa_long %>%
  mutate(group = factor(group, levels = group_levels)) %>%
  select(section, row, group, value) %>%
  tidyr::pivot_wider(names_from = group, values_from = value) %>%
  arrange(section, row)

# AUS HLE index (continuous) 
hle_aus_long <- bind_rows(
  tp_hle_aus %>%
    mutate(group = paste(country, timepoint, sep = " — ")) %>%
    transmute(section = "Home learning environment (AUS)",
              row = paste0(variable, ", n"),
              group, value = as.character(n)),
  tp_hle_aus %>%
    mutate(group = paste(country, timepoint, sep = " — ")) %>%
    transmute(section = "Home learning environment (AUS)",
              row = paste0(variable, ", Mean (SD)"),
              group, value = fmt_mean_sd(mean, sd, digits = 2))
)

hle_aus_wide <- hle_aus_long %>%
  mutate(group = factor(group, levels = group_levels)) %>%
  select(section, row, group, value) %>%
  tidyr::pivot_wider(names_from = group, values_from = value) %>%
  arrange(section, row)

# Categorical block (education SA/AUS + income AUS)
ses2_wide <- ses_tp_long2 %>%
  mutate(group = paste(country, timepoint, sep = " — "),
         group = factor(group, levels = group_levels)) %>%
  transmute(section = variable, row = level, group, value = cell) %>%
  tidyr::pivot_wider(names_from = group, values_from = value) %>%
  arrange(section, row)

paper_table2 <- bind_rows(ses2_wide, income2_wide, hle_aus_wide, hle_sa_wide) %>%
  mutate(section = factor(section, levels = c(
    "Caregiver education (AUS)",
    "Caregiver education (SA)",
    "Household income (AUS)",
    "Household income (SA)",
    "Home learning environment (AUS)",
    "Home learning environment (SA)"
  ))) %>%
  arrange(section, row)

gt2 <- paper_table2 %>%
  gt(groupname_col = "section", rowname_col = "row") %>%
  tab_source_note(
    source_note = md("**Note.** Summaries are restricted to children with any EF data at each wave (partial EF allowed). In Australia, caregiver education, household income, and the HLE Index are measured once per child and carried across waves; *n* and summary statistics may still differ across T1–T3 because the EF-available sample varies by wave (attrition/partial EF). In South Africa, caregiver education, income, and HLE measures are recorded by wave and summarised only where collected (later-wave cells are NA if not assessed).")
  ) %>%
  cols_align(align = "center") %>%
  tab_options(
    table.width = pct(100),
    row_group.as_column = TRUE,
    table.font.size = px(11)
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_row_groups()
  )

gt2
```
:::

```{r}
#| label: standardize
#| include: false

stopifnot(exists("sa_ef_long"), exists("aus_ef_long"))
stopifnot(exists("sa_age_long"), exists("aus_age_long"))

time_levels <- c("T1","T2","T3")
nodes <- c("ef_inhibition","ef_cogflex","ef_workingmem")

ef_labels <- c(
  ef_inhibition = "Inhibition",
  ef_cogflex    = "Cognitive flexibility",
  ef_workingmem = "Working memory"
)

ef_std <- ef_all %>%
  dplyr::group_by(variable) %>%
  dplyr::mutate(value_z = as.numeric(scale(value))) %>%
  dplyr::ungroup() %>%
  dplyr::left_join(
    age_all %>% dplyr::select(country, timepoint, id, age),
    by = c("country", "timepoint", "id")
  ) %>%
  dplyr::mutate(
    # enforce canonical codes (do NOT recode to names here)
    country = as.character(country),
    country = dplyr::case_when(
      country %in% c("AU", "Australia")      ~ "AU",
      country %in% c("SA", "South Africa")   ~ "SA",
      TRUE ~ country
    ),
    country  = factor(country, levels = c("AU", "SA")),
    timepoint = factor(as.character(timepoint), levels = time_levels, ordered = TRUE),
    id       = as.character(id),

    # derive task from VARIABLE (not from the existing label)
    task = factor(
      as.character(variable),
      levels = nodes,
      labels = unname(ef_labels[nodes])
    )
  )
```

```{r}
#| label: test-re-test
#| include: false

# keep only children who have >1 wave for a given task (within country)
# (ef_std already enforces canonical country codes AU/SA in the standardize chunk)

ef_retest_scores <- ef_std %>%
  dplyr::mutate(
    country   = factor(as.character(country), levels = c("AU","SA")),
    timepoint = factor(as.character(timepoint), levels = c("T1","T2","T3"), ordered = TRUE),
    id        = as.character(id)
  ) %>%
  dplyr::group_by(country, id, task) %>%
  dplyr::arrange(country, id, task, timepoint) %>%
  dplyr::filter(dplyr::n_distinct(timepoint) > 1) %>%
  dplyr::ungroup()

# wide format: one row per child × task (within country), columns per wave
# (also widens age so we can compute age gaps)
retest_wide <- ef_retest_scores %>%
  # if you *ever* have duplicates within a wave, this collapses safely
  dplyr::group_by(country, id, task, timepoint) %>%
  dplyr::summarise(
    value_z = mean(value_z, na.rm = TRUE),
    age     = mean(age,     na.rm = TRUE),
    .groups = "drop"
  ) %>%
  tidyr::pivot_wider(
    id_cols     = c(country, id, task),
    names_from  = timepoint,
    values_from = c(value_z, age),
    names_sep   = "_"
  ) %>%
  dplyr::mutate(
    mean_age      = rowMeans(dplyr::select(., dplyr::starts_with("age_")), na.rm = TRUE),
    age_gap_T12_y = age_T2 - age_T1,
    age_gap_T23_y = age_T3 - age_T2
  ) %>%
  dplyr::select(
    country, id, task,
    mean_age,
    age_gap_T12_y, age_gap_T23_y,
    value_z_T1, value_z_T2, value_z_T3
  )

# helper: only compute r if there are enough complete pairs
safe_cor <- function(a, b, min_n = 3) {
  n <- sum(stats::complete.cases(a, b))
  if (n < min_n) return(NA_real_)
  suppressWarnings(stats::cor(a, b, use = "complete.obs"))
}

# 3) test–retest correlations by country × task
trt <- retest_wide %>%
  dplyr::group_by(country, task) %>%
  dplyr::summarise(
    r_T12   = safe_cor(value_z_T1, value_z_T2),
    n_T12   = sum(stats::complete.cases(value_z_T1, value_z_T2)),
    gap_T12 = mean(age_gap_T12_y, na.rm = TRUE) * 12,  # months

    r_T23   = safe_cor(value_z_T2, value_z_T3),
    n_T23   = sum(stats::complete.cases(value_z_T2, value_z_T3)),
    gap_T23 = mean(age_gap_T23_y, na.rm = TRUE) * 12,  # months
    .groups = "drop"
  ) %>%
  dplyr::arrange(task, country)

trt

```

# Age associations {.appendix #render-test-re-test-plot}
```{r}
#| label: test-re-test-plot
#| fig-cap: "Executive Function associations across waves. Note: Standardised scores (z); colour indicates mean age across available waves"
#| include: true
#| fig-align: center
#| fig-width: 8
#| fig-height: 5
#| fig-pos: 'H'

# From retest_wide -> one row per child × task × pair (T1–T2 and T2–T3),
# then build a single row facet that only includes observed combos.

retest_long_pairs <- dplyr::bind_rows(
  retest_wide %>%
    dplyr::transmute(
      country, id, task, mean_age,
      pair = "T1–T2",
      x = value_z_T1, y = value_z_T2
    ),
  retest_wide %>%
    dplyr::transmute(
      country, id, task, mean_age,
      pair = "T2–T3",
      x = value_z_T2, y = value_z_T3
    )
) %>%
  dplyr::filter(!is.na(x) & !is.na(y)) %>%
  dplyr::mutate(
    country = factor(as.character(country), levels = c("AU","SA")),
    pair    = factor(pair, levels = c("T1–T2", "T2–T3")),
    row_facet = paste(country, pair, sep = "\n"),
    row_facet = factor(
      row_facet,
      levels = c(
        "AU\nT1–T2",
        "AU\nT2–T3",
        "SA\nT1–T2"
      )
    )
  )

# Panel stats (r + N), using the same "safe" logic as above
pair_stats <- retest_long_pairs %>%
  dplyr::group_by(country, task, pair, row_facet) %>%
  dplyr::summarise(
    n = sum(stats::complete.cases(x, y)),
    r = safe_cor(x, y, min_n = 3),
    .groups = "drop"
  ) %>%
  dplyr::mutate(
    label = ifelse(
      is.na(r),
      paste0("r = NA\nN = ", n),
      paste0("r = ", sprintf("%.2f", r), "\nN = ", n)
    )
  )

# Plot
p_retest_simple <- ggplot(retest_long_pairs, aes(x = x, y = y)) +
  geom_abline(slope = 1, intercept = 0, linetype = "dotted", alpha = 0.6) +
  geom_point(aes(colour = mean_age), alpha = 0.5, size = 1.4) +
  geom_smooth(method = "lm", formula = y ~ x, se = TRUE) +
  geom_text(
    data = pair_stats,
    aes(label = label),
    x = -Inf, y = Inf,
    inherit.aes = FALSE,
    hjust = -0.05, vjust = 1.1, size = 3.5
  ) +
  facet_grid(row_facet ~ task) +
  labs(
    x = "Earlier wave (z)",
    y = "Later wave (z)",
    colour = "Mean age (years)"
  ) +
  theme(legend.position = "bottom")

p_retest_simple

```

# Executive Function across waves {.appendix #age-ef-wave}
```{r}
#| label: age-ef-wave
#| fig-cap: "Executive Function by age across waves (z-scored within EF task). Note: Points jittered + transparent; lines are linear fits with 95% CI"
#| include: true
#| fig-align: center
#| fig-width: 8
#| fig-height: 5
#| fig-pos: 'H'

# set up plot scales
.scale_colour_country <- function() {
  scale_colour_discrete()
}

# Age x EF x wave (standardized)
p_age_by_wave <- ggplot(
  ef_std %>%
    dplyr::filter(!is.na(age), !is.na(value_z)) %>%
    dplyr::mutate(
      country   = factor(as.character(country), levels = c("AU","SA")),
      timepoint = factor(as.character(timepoint), levels = c("T1","T2","T3"), ordered = TRUE)
    ),
  aes(x = age, y = value_z, colour = country)
) +
  geom_point(
    alpha = 0.15, size = 1,
    position = position_jitter(width = 0.03, height = 0.03)
  ) +
  geom_smooth(
    method = "lm", formula = y ~ x, se = TRUE, linewidth = 1
  ) +
  facet_grid(timepoint ~ task, scales = "fixed") +
  labs(
    x = "Age (years)",
    y = "EF (z-score within task)",
    colour = "Country"
  ) +
  .scale_colour_country() +
  theme(legend.position = "bottom")

p_age_by_wave
```

```{r}
#| label: restricted-sample
#| include: false

# restricted to at least 2 waves sample
# SA: EF observed at T1 and T2
# AU: strict (T1+T2+T3) or lenient (T1+T2)
#
# NOTE: ef_std should already be using canonical country codes (AU/SA) from the standardize chunk.
# We still normalise defensively here in case something upstream changes later.

# Wave-level EF presence flag: "any EF observed at this wave"
flags <- ef_std %>%
  dplyr::mutate(
    country = dplyr::case_when(
      as.character(country) %in% c("AU", "Australia")    ~ "AU",
      as.character(country) %in% c("SA", "South Africa") ~ "SA",
      TRUE ~ as.character(country)
    ),
    id       = as.character(id),
    timepoint = as.character(timepoint)
  ) %>%
  dplyr::group_by(country, id, timepoint) %>%
  dplyr::summarise(any_ef = any(!is.na(value_z)), .groups = "drop")

# SA keep: must have T1 & T2
sa_keep_ids <- flags %>%
  dplyr::filter(country == "SA", timepoint %in% c("T1","T2")) %>%
  dplyr::group_by(country, id) %>%
  dplyr::summarise(
    has_T1 = any(timepoint == "T1" & any_ef),
    has_T2 = any(timepoint == "T2" & any_ef),
    .groups = "drop"
  ) %>%
  dplyr::filter(has_T1 & has_T2) %>%
  dplyr::select(country, id)

# AU keep: strict vs lenient
au_keep_ids_strict <- flags %>%
  dplyr::filter(country == "AU", timepoint %in% c("T1","T2","T3")) %>%
  dplyr::group_by(country, id) %>%
  dplyr::summarise(
    has_T1 = any(timepoint == "T1" & any_ef),
    has_T2 = any(timepoint == "T2" & any_ef),
    has_T3 = any(timepoint == "T3" & any_ef),
    .groups = "drop"
  ) %>%
  dplyr::filter(has_T1 & has_T2 & has_T3) %>%
  dplyr::select(country, id)

au_keep_ids_t12 <- flags %>%
  dplyr::filter(country == "AU", timepoint %in% c("T1","T2")) %>%
  dplyr::group_by(country, id) %>%
  dplyr::summarise(
    has_T1 = any(timepoint == "T1" & any_ef),
    has_T2 = any(timepoint == "T2" & any_ef),
    .groups = "drop"
  ) %>%
  dplyr::filter(has_T1 & has_T2) %>%
  dplyr::select(country, id)

au_restriction <- "strict"  # "strict" or "t12"
au_keep_ids <- if (au_restriction == "strict") au_keep_ids_strict else au_keep_ids_t12

keep_ids_all <- dplyr::bind_rows(sa_keep_ids, au_keep_ids)

# Apply restriction to ef_std (keep AU/SA codes; do NOT recode to names)
ef_restricted <- ef_std %>%
  dplyr::mutate(
    country = dplyr::case_when(
      as.character(country) %in% c("AU", "Australia")    ~ "AU",
      as.character(country) %in% c("SA", "South Africa") ~ "SA",
      TRUE ~ as.character(country)
    ),
    id       = as.character(id),
    timepoint = factor(as.character(timepoint), levels = c("T1","T2","T3"), ordered = TRUE)
  ) %>%
  dplyr::inner_join(keep_ids_all, by = c("country","id"))

```

# Executive Function scores over time {.appendix #mean-trend}
```{r}
#| label: mean-trend
#| include: true
#| fig-align: center
#| fig-width: 8
#| fig-height: 5
#| fig-pos: 'H'
#| fig-cap: |
#|   **Mean EF scores over time (children with repeated EF data).**  
#|   *Note.* “EF observed” at a wave means at least one EF task score is non-missing. The analytic sample includes only children meeting the wave-coverage rule: SA = EF observed at both T1 and T2; AU = EF observed at T1–T3 (“strict”) or at T1 and T2 (“t12”)."

# Mean trend over time (standardised, restricted sample)
mean_df <- ef_restricted %>%
  dplyr::mutate(
    # task already exists in ef_std; keep it and just ensure levels are stable
    task = factor(as.character(task), levels = unname(ef_labels[nodes])),
    country = factor(as.character(country), levels = c("AU","SA")),
    timepoint = factor(as.character(timepoint), levels = c("T1","T2","T3"), ordered = TRUE)
  ) %>%
  dplyr::group_by(country, task, timepoint) %>%
  dplyr::summarise(
    n  = sum(!is.na(value_z)),
    m  = mean(value_z, na.rm = TRUE),
    se = sd(value_z, na.rm = TRUE) / sqrt(n),
    lo = m - 1.96 * se,
    hi = m + 1.96 * se,
    .groups = "drop"
  )

p_mean_trend <- ggplot(mean_df, aes(x = timepoint, y = m, group = 1)) +
  geom_line(linewidth = 1) +
  geom_point(size = 2.2) +
  geom_errorbar(aes(ymin = lo, ymax = hi), width = 0.10) +
  facet_grid(country ~ task) +
  labs(
    x = "Timepoint",
    y = "Mean EF (z-score)"
  ) +
  theme_bw(base_size = 11) +
  theme(
    legend.position = "none",
    panel.grid.minor = element_blank(),
    strip.background = element_blank()
  )

p_mean_trend
```

# Executive Function individual trajectories {.appendix #spaghetti-plot}
```{r}
#| label: spaghetti-plot
#| include: true
#| fig-align: center
#| fig-width: 8
#| fig-height: 5
#| fig-pos: 'H'
#| fig-cap: |
#|   **Individual EF trajectories over time (children with repeated EF data).**  
#|   *Note.* “EF observed” at a wave means at least one EF task score is non-missing. The analytic sample includes only children meeting the wave-coverage rule: SA = EF observed at both T1 and T2; AU = EF observed at T1–T3 (“strict”) or at T1 and T2 (“t12”). Mean ± 95% CI is overlaid. EF scores are z-scored within task (pooled).

# Align factor structure to the 'standardize' chunk:
# - country stays AU/SA (canonical codes)
# - task uses the pretty labels created in ef_std (already a factor)
# - timepoint uses T1/T2/T3 (ordered)

ef_restricted_lab <- ef_restricted %>%
  dplyr::mutate(
    country   = dplyr::case_when(
      as.character(country) %in% c("AU", "Australia")    ~ "AU",
      as.character(country) %in% c("SA", "South Africa") ~ "SA",
      TRUE ~ as.character(country)
    ),
    country   = factor(country, levels = c("AU","SA")),
    task      = factor(as.character(task), levels = unname(ef_labels[nodes])),
    timepoint = factor(as.character(timepoint), levels = c("T1","T2","T3"), ordered = TRUE),
    id        = as.character(id)
  )

mean_df_lab <- mean_df %>%
  dplyr::mutate(
    country   = dplyr::case_when(
      as.character(country) %in% c("AU", "Australia")    ~ "AU",
      as.character(country) %in% c("SA", "South Africa") ~ "SA",
      TRUE ~ as.character(country)
    ),
    country   = factor(country, levels = c("AU","SA")),
    task      = factor(as.character(task), levels = unname(ef_labels[nodes])),
    timepoint = factor(as.character(timepoint), levels = c("T1","T2","T3"), ordered = TRUE)
  )

p_spaghetti <- ggplot(ef_restricted_lab, aes(x = timepoint, y = value_z, group = id)) +
  geom_line(alpha = 0.08) +
  geom_point(alpha = 0.08, size = 0.7) +
  geom_line(
    data = mean_df_lab,
    aes(x = timepoint, y = m, group = 1),
    inherit.aes = FALSE,
    linewidth = 1.0
  ) +
  geom_point(
    data = mean_df_lab,
    aes(x = timepoint, y = m),
    inherit.aes = FALSE,
    size = 2.2
  ) +
  geom_errorbar(
    data = mean_df_lab,
    aes(x = timepoint, ymin = lo, ymax = hi),
    inherit.aes = FALSE,
    width = 0.10
  ) +
  facet_grid(country ~ task) +
  labs(
    x = "Timepoint",
    y = "EF (z-score)"
  ) +
  theme_bw(base_size = 11) +
  theme(
    legend.position = "none",
    panel.grid.minor = element_blank(),
    strip.background = element_blank()
  )

p_spaghetti

```

```{r}
#| label: excess-code
#| include: false
# excess code to be removed
table(sa_data$hle_read_books)
table(sa_data$hle_read_who___1)
table(sa_data$hle_read_who___2)
table(sa_data$hle_read_who___3)
table(sa_data$hle_read_who___4)
table(sa_data$hle_read_who___5)
table(sa_data$hle_read_who___6)
table(sa_data$hle_read_who___unk)
table(sa_data$hle_read_who___na)
table(sa_data$hle_read_who___999)
table(sa_data$hle_read_who___9999)
table(sa_data$hle_read_specify)
table(sa_data$hle_stories)    
table(sa_data$hle_stories_who___1)
table(sa_data$hle_stories_who___2)
table(sa_data$hle_stories_who___3)
table(sa_data$hle_stories_who___4)
table(sa_data$hle_stories_who___5)
table(sa_data$hle_stories_who___6)
table(sa_data$hle_stories_who___unk)
table(sa_data$hle_stories_who___na)
table(sa_data$hle_stories_who___999)
table(sa_data$hle_stories_who___9999)
table(sa_data$hle_stories_specify)
table(sa_data$hle_songs)
table(sa_data$hle_songs_who___1)
table(sa_data$hle_songs_who___2)
table(sa_data$hle_songs_who___3)
table(sa_data$hle_songs_who___4)
table(sa_data$hle_songs_who___5)
table(sa_data$hle_songs_who___6)
table(sa_data$hle_songs_who___unk)
table(sa_data$hle_songs_who___na)
table(sa_data$hle_songs_who___999)
table(sa_data$hle_songs_who___9999)
table(sa_data$hle_songs_specify)
table(sa_data$hle_outside)
table(sa_data$hle_outside_who___1)
table(sa_data$hle_outside_who___2)
table(sa_data$hle_outside_who___3)
table(sa_data$hle_outside_who___4)
table(sa_data$hle_outside_who___5)
table(sa_data$hle_outside_who___6)
table(sa_data$hle_outside_who___unk)
table(sa_data$hle_outside_who___na)
table(sa_data$hle_outside_who___999)
table(sa_data$hle_outside_who___9999)
table(sa_data$hle_outside_specify)
table(sa_data$hle_play)
table(sa_data$hle_play_who___1)
table(sa_data$hle_play_who___2)
table(sa_data$hle_play_who___3)
table(sa_data$hle_play_who___4)
table(sa_data$hle_play_who___5)
table(sa_data$hle_play_who___6)
table(sa_data$hle_play_who___unk)
table(sa_data$hle_play_who___na)
table(sa_data$hle_play_who___999)
table(sa_data$hle_play_who___9999)
table(sa_data$hle_play_specify)
table(sa_data$hle_names)
table(sa_data$hle_names_who___1)
table(sa_data$hle_names_who___2)
table(sa_data$hle_names_who___3)
table(sa_data$hle_names_who___4)
table(sa_data$hle_names_who___5)
table(sa_data$hle_names_who___6)
table(sa_data$hle_names_who___unk)
table(sa_data$hle_names_who___na)
table(sa_data$hle_names_who___999)
table(sa_data$hle_names_who___999)
table(sa_data$hle_names_specify)
table(sa_data$hle_count)
table(sa_data$hle_count_who___1)
table(sa_data$hle_count_who___2)
table(sa_data$hle_count_who___3)
table(sa_data$hle_count_who___4)
table(sa_data$hle_count_who___5)
table(sa_data$hle_count_who___6)
table(sa_data$hle_count_who___unk)
table(sa_data$hle_count_who___na)
table(sa_data$hle_count_who___999)
table(sa_data$hle_count_who___9999)
table(sa_data$hle_count_specify)
table(sa_data$hle_draw)
table(sa_data$hle_draw_who___1)
table(sa_data$hle_draw_who___2)
table(sa_data$hle_draw_who___3)
table(sa_data$hle_draw_who___4)
table(sa_data$hle_draw_who___5)
table(sa_data$hle_draw_who___6)
table(sa_data$hle_draw_who___unk)
table(sa_data$hle_draw_who___na)
table(sa_data$hle_draw_who___999)
table(sa_data$hle_draw_who___9999)
table(sa_data$hle_draw_specify)
table(sa_data$hle_freqency_score)
table(sa_data$hle_time_week)
table(sa_data$hle_time_weekend)
table(sa_data$total_time_with_child)
table(sa_data$hle_books_home)
table(sa_data$hle_books_number)
table(sa_data$hle_homemade_toys)
table(sa_data$hle_homemade_toys_specify)
table(sa_data$hle_toys_shop)
table(sa_data$hle_toys_shop_specify)
table(sa_data$hle_household_objects)
table(sa_data$hle_objects_specify)
table(sa_data$books_toys_house_total)
```

